"use strict";(self.webpackChunkaudition=self.webpackChunkaudition||[]).push([[709],{3543:(n,a,s)=>{s.r(a),s.d(a,{data:()=>e});const e={key:"v-645f8064",path:"/java/multithreadingadvanced.html",title:"1. 多线程-进阶",lang:"en-EN",frontmatter:{},excerpt:"",headers:[{level:2,title:"1.1. 说一说自己对于 synchronized 关键字的了解",slug:"_1-1-说一说自己对于-synchronized-关键字的了解",children:[]},{level:2,title:"1.2. 说说自己是怎么使用 synchronized 关键字",slug:"_1-2-说说自己是怎么使用-synchronized-关键字",children:[{level:3,title:"1.2.1. 修饰实例方法",slug:"_1-2-1-修饰实例方法",children:[]},{level:3,title:"1.2.2. 修饰静态方法",slug:"_1-2-2-修饰静态方法",children:[]},{level:3,title:"1.2.3. 修饰代码块",slug:"_1-2-3-修饰代码块",children:[]},{level:3,title:"1.2.4. 总结",slug:"_1-2-4-总结",children:[]}]},{level:2,title:"1.3. synchronized 关键字的具体使用, 双重校验锁实现对象单例(线程安全)",slug:"_1-3-synchronized-关键字的具体使用-双重校验锁实现对象单例-线程安全",children:[]},{level:2,title:"1.4. 构造方法可以使用 synchronized 关键字修饰么?",slug:"_1-4-构造方法可以使用-synchronized-关键字修饰么",children:[]},{level:2,title:"1.5. 为什么要弄一个 CPU 高速缓存呢?",slug:"_1-5-为什么要弄一个-cpu-高速缓存呢",children:[]},{level:2,title:"1.6. 讲一下 JMM(Java 内存模型)",slug:"_1-6-讲一下-jmm-java-内存模型",children:[]},{level:2,title:"1.7. 并发编程的三个重要特性",slug:"_1-7-并发编程的三个重要特性",children:[]},{level:2,title:"1.8. 说说 synchronized 关键字和 volatile 关键字的区别",slug:"_1-8-说说-synchronized-关键字和-volatile-关键字的区别",children:[]},{level:2,title:"1.9. ThreadLocal 了解么?",slug:"_1-9-threadlocal-了解么",children:[]},{level:2,title:"1.10. ThreadLocal 内存泄露问题?",slug:"_1-10-threadlocal-内存泄露问题",children:[]},{level:2,title:"1.11. 为什么要用线程池?",slug:"_1-11-为什么要用线程池",children:[{level:3,title:"1.11.1. 使用线程池的好处",slug:"_1-11-1-使用线程池的好处",children:[]}]},{level:2,title:"1.12. 实现 Runnable 接口和 Callable 接口的区别",slug:"_1-12-实现-runnable-接口和-callable-接口的区别",children:[]},{level:2,title:"1.13. 执行 execute()方法和 submit()方法的区别是什么呢?",slug:"_1-13-执行-execute-方法和-submit-方法的区别是什么呢",children:[]},{level:2,title:"1.14. 如何创建线程池",slug:"_1-14-如何创建线程池",children:[{level:3,title:"1.14.1. 通过 Executor 框架的工具类 Executors 来实现",slug:"_1-14-1-通过-executor-框架的工具类-executors-来实现",children:[]},{level:3,title:"1.14.2. ThreadPoolExecutor 类分析",slug:"_1-14-2-threadpoolexecutor-类分析",children:[]},{level:3,title:"1.14.3. threadPoolExecutor 构造函数重要参数分析",slug:"_1-14-3-threadpoolexecutor-构造函数重要参数分析",children:[]},{level:3,title:"1.14.4. hreadPoolExecutor 饱和策略",slug:"_1-14-4-hreadpoolexecutor-饱和策略",children:[]},{level:3,title:"1.14.5. 线程池原理分析",slug:"_1-14-5-线程池原理分析",children:[]}]},{level:2,title:"1.15. 介绍一下 Atomic 原子类",slug:"_1-15-介绍一下-atomic-原子类",children:[]},{level:2,title:"1.16. JUC 包中的原子类是哪 4 类?",slug:"_1-16-juc-包中的原子类是哪-4-类",children:[{level:3,title:"1.16.1. 基本类型",slug:"_1-16-1-基本类型",children:[]},{level:3,title:"1.16.2. 数组类型",slug:"_1-16-2-数组类型",children:[]},{level:3,title:"1.16.3. 引用类型",slug:"_1-16-3-引用类型",children:[]},{level:3,title:"1.16.4. 对象的属性修改类型",slug:"_1-16-4-对象的属性修改类型",children:[]}]}],filePathRelative:"java/multithreadingadvanced.md",git:{updatedTime:164087111e4,contributors:[{name:"shorestraydog",email:"shorestraydog@protonmail.com",commits:2}]}}},9804:(n,a,s)=>{s.r(a),s.d(a,{default:()=>t});const e=(0,s(6252).uE)('<h1 id="_1-多线程-进阶" tabindex="-1"><a class="header-anchor" href="#_1-多线程-进阶" aria-hidden="true">#</a> 1. 多线程-进阶</h1><h2 id="_1-1-说一说自己对于-synchronized-关键字的了解" tabindex="-1"><a class="header-anchor" href="#_1-1-说一说自己对于-synchronized-关键字的了解" aria-hidden="true">#</a> 1.1. 说一说自己对于 synchronized 关键字的了解</h2><p>synchronized 关键字解决的是多线程之间访问资源的同步性, synchronized 关键字可以保证被它修饰的方法或者代码块在任意时刻只有一个线程执行.</p><h2 id="_1-2-说说自己是怎么使用-synchronized-关键字" tabindex="-1"><a class="header-anchor" href="#_1-2-说说自己是怎么使用-synchronized-关键字" aria-hidden="true">#</a> 1.2. 说说自己是怎么使用 synchronized 关键字</h2><h3 id="_1-2-1-修饰实例方法" tabindex="-1"><a class="header-anchor" href="#_1-2-1-修饰实例方法" aria-hidden="true">#</a> 1.2.1. 修饰实例方法</h3><p>作用于当前对象实例加锁, 进入同步代码前要获得当前对象实例的锁</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">synchronized</span> <span class="token keyword">void</span> <span class="token function">method</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>\n<span class="token comment">//业务代码</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><h3 id="_1-2-2-修饰静态方法" tabindex="-1"><a class="header-anchor" href="#_1-2-2-修饰静态方法" aria-hidden="true">#</a> 1.2.2. 修饰静态方法</h3><p>给当前类加锁, 会作用于类的所有对象实例, 进入同步代码前要获得当前 class 的锁. 因为静态成员不属于任何一个实例对象, 是类成员(<em>static 表明这是该类的一个静态资源, 不管 new 了多少个对象, 只有一份</em>). 所以, 如果一个线程 A 调用一个实例对象的非静态 synchronized 方法, 而线程 B 需要调用这个实例对象所属类的静态 synchronized 方法, 是允许的, 不会发生互斥现象, 因为访问静态 synchronized 方法占用的锁是当前类的锁, 而访问非静态 synchronized 方法占用的锁是当前实例对象锁.</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">synchronized</span> staic <span class="token keyword">void</span> <span class="token function">method</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>\n<span class="token comment">//业务代码</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><h3 id="_1-2-3-修饰代码块" tabindex="-1"><a class="header-anchor" href="#_1-2-3-修饰代码块" aria-hidden="true">#</a> 1.2.3. 修饰代码块</h3><p>指定加锁对象, 对给定对象/类加锁. synchronized(this|object)表示进入同步代码库前要获得给定对象的锁. synchronized(类. class)表示进入同步代码前要获得当前 class 的锁</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">synchronized</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">{</span>\n<span class="token comment">//业务代码</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><h3 id="_1-2-4-总结" tabindex="-1"><a class="header-anchor" href="#_1-2-4-总结" aria-hidden="true">#</a> 1.2.4. 总结</h3><ol><li>synchronized 关键字加到 static 静态方法和 synchronized(class)代码块上都是是给 Class 类上锁.</li><li>synchronized 关键字加到实例方法上是给对象实例上锁.</li><li>尽量不要使用 synchronized(Stringa)因为 JVM 中, 字符串常量池具有缓存功能!</li></ol><p>面试中面试官经常会说: &quot;单例模式了解吗?来给我手写一下!给我解释一下双重检验锁方式实现单例模式的原理呗!&quot;</p><h2 id="_1-3-synchronized-关键字的具体使用-双重校验锁实现对象单例-线程安全" tabindex="-1"><a class="header-anchor" href="#_1-3-synchronized-关键字的具体使用-双重校验锁实现对象单例-线程安全" aria-hidden="true">#</a> 1.3. synchronized 关键字的具体使用, 双重校验锁实现对象单例(线程安全)</h2><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Singleton</span> <span class="token punctuation">{</span>\n   <span class="token keyword">private</span> <span class="token keyword">volatile</span> <span class="token keyword">static</span> <span class="token class-name">Singleton</span> uniqueInstance<span class="token punctuation">;</span>\n   <span class="token keyword">private</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>\n  <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">Singleton</span> <span class="token function">getUniqueInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n     <span class="token comment">//先判断对象是否已经实例过，没有实例化过才进入加锁代码</span>\n       <span class="token keyword">if</span> <span class="token punctuation">(</span>uniqueInstance <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n           <span class="token comment">//类对象加锁</span>\n           <span class="token keyword">synchronized</span> <span class="token punctuation">(</span><span class="token class-name">Singleton</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n               <span class="token keyword">if</span> <span class="token punctuation">(</span>uniqueInstance <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n                   uniqueInstance <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n               <span class="token punctuation">}</span>\n           <span class="token punctuation">}</span>\n       <span class="token punctuation">}</span>\n      <span class="token keyword">return</span> uniqueInstance<span class="token punctuation">;</span>\n  <span class="token punctuation">}</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br></div></div><p>uniqueInstance 采用 volatile 关键字修饰也是很有必要的，uniqueInstance = new Singleton (); 这段代码其实是分为三步执行：</p><ol><li><p>为 uniqueInstance 分配内存空间</p></li><li><p>初始化 uniqueInstance</p></li><li><p>将 uniqueInstance 指向分配的内存地址</p><p>由于 JVM 具有指令重排的特性，执行顺序有可能变成 1-&gt;3-&gt;2。在多线程环境下会导致一个线程获得还没有初始化的实例。例如，线程 T1 执行了 1 和 3，此时 T2 调用 getUniqueInstance () 发现 uniqueInstance 不为空，因此返回 uniqueInstance，但此时 uniqueInstance 还未被初始化。</p></li></ol><h2 id="_1-4-构造方法可以使用-synchronized-关键字修饰么" tabindex="-1"><a class="header-anchor" href="#_1-4-构造方法可以使用-synchronized-关键字修饰么" aria-hidden="true">#</a> 1.4. 构造方法可以使用 synchronized 关键字修饰么?</h2><p>构造方法不能使用 synchronized 关键字修饰. 构造方法本身就属于线程安全的, 不存在同步的构造方法一说.</p><h2 id="_1-5-为什么要弄一个-cpu-高速缓存呢" tabindex="-1"><a class="header-anchor" href="#_1-5-为什么要弄一个-cpu-高速缓存呢" aria-hidden="true">#</a> 1.5. 为什么要弄一个 CPU 高速缓存呢?</h2><p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/2020-8/303a300f-70dd-4ee1-9974-3f33affc6574.png" alt=""></p><p>CPU 缓存则是为了解决 CPU 处理速度和内存处理速度不对等的问题.</p><p>先复制一份数据到 CPUCache 中, 当 CPU 需要用到的时候就可以直接从 CPUCache 中读取数据, 当运算完成后, 再将运算得到的数据写回 MainMemory 中</p><h2 id="_1-6-讲一下-jmm-java-内存模型" tabindex="-1"><a class="header-anchor" href="#_1-6-讲一下-jmm-java-内存模型" aria-hidden="true">#</a> 1.6. 讲一下 JMM(Java 内存模型)</h2><p>在当前的 Java 内存模型下, 线程可以把变量保存本地内存(比如机器的寄存器)中, 而不是直接在主存中进行读写. 这就可能造成一个线程在主存中修改了一个变量的值, 而另外一个线程还继续使用它在寄存器中的变量值的拷贝, 造成数据的不一致.</p><p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/2020-8/0ac7e663-7db8-4b95-8d8e-7d2b179f67e8.png" alt="JMM(Java内存模型)"></p><p>要解决这个问题, 就需要把变量声明为 volatile, 这就指示 JVM, 这个变量是共享且不稳定的, 每次使用它都到主存中进行读取.</p><p>所以, volatile 关键字除了防止 JVM 的指令重排, 还有一个重要的作用就是保证变量的可见性.</p><p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/2020-8/d49c5557-140b-4abf-adad-8aac3c9036cf.png" alt="volatile关键字的可见性"></p><h2 id="_1-7-并发编程的三个重要特性" tabindex="-1"><a class="header-anchor" href="#_1-7-并发编程的三个重要特性" aria-hidden="true">#</a> 1.7. 并发编程的三个重要特性</h2><ol><li>原子性 : 一个操作或者多次操作, 要么所有的操作全部都得到执行并且不会收到任何因素的干扰而中断, 要么所有的操作都执行, 要么都不执行. synchronized 可以保证代码片段的原子性.</li><li>可见性 : 当一个线程对共享变量进行了修改, 那么另外的线程都是立即可以看到修改后的最新值. volatile 关键字可以保证共享变量的可见性.</li><li>有序性 : 代码在执行的过程中的先后顺序, Java 在编译器以及运行期间的优化, 代码的执行顺序未必就是编写代码时候的顺序. volatile 关键字可以禁止指令进行重排序优化</li></ol><h2 id="_1-8-说说-synchronized-关键字和-volatile-关键字的区别" tabindex="-1"><a class="header-anchor" href="#_1-8-说说-synchronized-关键字和-volatile-关键字的区别" aria-hidden="true">#</a> 1.8. 说说 synchronized 关键字和 volatile 关键字的区别</h2><p>synchronized 关键字和 volatile 关键字是两个互补的存在, 而不是对立的存在!</p><ol><li>volatile 关键字是线程同步的轻量级实现, 所以 volatile 性能肯定比 synchronized 关键字要好. 但是 volatile 关键字只能用于变量而 synchronized 关键字可以修饰方法以及代码块.</li><li>volatile 关键字能保证数据的可见性, 但不能保证数据的原子性. synchronized 关键字两者都能保证.</li><li>volatile 关键字主要用于解决变量在多个线程之间的可见性, 而 synchronized 关键字解决的是多个线程之间访问资源的同步性.</li></ol><h2 id="_1-9-threadlocal-了解么" tabindex="-1"><a class="header-anchor" href="#_1-9-threadlocal-了解么" aria-hidden="true">#</a> 1.9. ThreadLocal 了解么?</h2><p>通常情况下, 创建的变量是可以被任何一个线程访问并修改的. 如果想实现每一个线程都有自己的专属本地变量可以使用 ThreadLocal</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>text<span class="token punctuation">.</span></span><span class="token class-name">SimpleDateFormat</span><span class="token punctuation">;</span>\n<span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span></span><span class="token class-name">Random</span><span class="token punctuation">;</span>\n\n<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ThreadLocalExample</span> <span class="token keyword">implements</span> <span class="token class-name">Runnable</span><span class="token punctuation">{</span>\n\n     <span class="token comment">// SimpleDateFormat 不是线程安全的, 所以每个线程都要有自己独立的副本</span>\n    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">ThreadLocal</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">SimpleDateFormat</span><span class="token punctuation">&gt;</span></span> formatter <span class="token operator">=</span> <span class="token class-name">ThreadLocal</span><span class="token punctuation">.</span><span class="token function">withInitial</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token keyword">new</span> <span class="token class-name">SimpleDateFormat</span><span class="token punctuation">(</span><span class="token string">&quot;yyyyMMdd HHmm&quot;</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">InterruptedException</span> <span class="token punctuation">{</span>\n        <span class="token class-name">ThreadLocalExample</span> obj <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ThreadLocalExample</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span> <span class="token punctuation">;</span> i<span class="token operator">&lt;</span><span class="token number">10</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>\n            <span class="token class-name">Thread</span> t <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span> <span class="token string">&quot;&quot;</span><span class="token operator">+</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>\n            <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Random</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">nextInt</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n            t<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n        <span class="token punctuation">}</span>\n    <span class="token punctuation">}</span>\n\n    <span class="token annotation punctuation">@Override</span>\n    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;Thread Name= &quot;</span><span class="token operator">+</span><span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token string">&quot; default Formatter = &quot;</span><span class="token operator">+</span>formatter<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toPattern</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n        <span class="token keyword">try</span> <span class="token punctuation">{</span>\n            <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Random</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">nextInt</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n        <span class="token punctuation">}</span>\n        <span class="token comment">//formatter pattern is changed here by thread, but it won&#39;t reflect to other threads</span>\n        formatter<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">SimpleDateFormat</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;Thread Name= &quot;</span><span class="token operator">+</span><span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token string">&quot; formatter = &quot;</span><span class="token operator">+</span>formatter<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toPattern</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n\n<span class="token punctuation">}</span>\n\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br></div></div><h2 id="_1-10-threadlocal-内存泄露问题" tabindex="-1"><a class="header-anchor" href="#_1-10-threadlocal-内存泄露问题" aria-hidden="true">#</a> 1.10. ThreadLocal 内存泄露问题?</h2><p>ThreadLocalMap 中使用的 key 为 ThreadLocal 的弱引用, 而 value 是强引用. 所以, 如果 ThreadLocal 没有被外部强引用的情况下, 在垃圾回收的时候, key 会被清理掉, 而 value 不会被清理掉. 这样一来, ThreadLocalMap 中就会出现 key 为 null 的 Entry. 假如我们不做任何措施的话, value 永远无法被 GC 回收, 这个时候就可能会产生内存泄露. ThreadLocalMap 实现中已经考虑了这种情况, 在调用 set(), get(), remove()方法的时候, 会清理掉 key 为 null 的记录.</p><h2 id="_1-11-为什么要用线程池" tabindex="-1"><a class="header-anchor" href="#_1-11-为什么要用线程池" aria-hidden="true">#</a> 1.11. 为什么要用线程池?</h2><p>池化技术的思想主要是为了减少每次获取资源的消耗, 提高对资源的利用率. 线程池, 数据库连接池, Http 连接池等等都是对这个思想的应用.</p><h3 id="_1-11-1-使用线程池的好处" tabindex="-1"><a class="header-anchor" href="#_1-11-1-使用线程池的好处" aria-hidden="true">#</a> 1.11.1. 使用线程池的好处</h3><ol><li>降低资源消耗. 通过重复利用已创建的线程降低线程创建和销毁造成的消耗.</li><li>提高响应速度. 当任务到达时, 任务可以不需要的等到线程创建就能立即执行.</li><li>提高线程的可管理性. 线程是稀缺资源, 如果无限制的创建, 不仅会消耗系统资源, 还会降低系统的稳定性, 使用线程池可以进行统一的分配, 调优和监控.</li></ol><h2 id="_1-12-实现-runnable-接口和-callable-接口的区别" tabindex="-1"><a class="header-anchor" href="#_1-12-实现-runnable-接口和-callable-接口的区别" aria-hidden="true">#</a> 1.12. 实现 Runnable 接口和 Callable 接口的区别</h2><p>Runnable 接口不会返回结果或抛出检查异常, 但是 Callable 接口可以.</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token comment">// Runnable. java</span>\n<span class="token annotation punctuation">@FunctionalInterface</span>\n<span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Runnable</span><span class="token punctuation">{</span>\n<span class="token comment">// *被线程执行, 没有返回值也无法抛出异常</span>\n   <span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n\n<span class="token comment">// Callable. java</span>\n<span class="token annotation punctuation">@FunctionalInterface</span>\n<span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Callable</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">{</span>\n<span class="token comment">// 计算结果, 或在无法这样做时抛出异常.</span>\n<span class="token comment">// @return计算得出的结果</span>\n<span class="token comment">// @throws如果无法计算结果, 则抛出异常</span>\n  <span class="token class-name">V</span> <span class="token function">call</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br></div></div><p>工具类 Executors 可以实现将 Runnable 对象转换成 Callable 对象.</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token class-name">Executors</span><span class="token punctuation">.</span><span class="token function">callable</span><span class="token punctuation">(</span><span class="token class-name">Runnable</span> task<span class="token punctuation">)</span>\n<span class="token class-name">Executors</span><span class="token punctuation">.</span><span class="token function">callable</span><span class="token punctuation">(</span><span class="token class-name">Runnable</span> task<span class="token punctuation">,</span> <span class="token class-name">Object</span> result<span class="token punctuation">)</span><span class="token punctuation">)</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><h2 id="_1-13-执行-execute-方法和-submit-方法的区别是什么呢" tabindex="-1"><a class="header-anchor" href="#_1-13-执行-execute-方法和-submit-方法的区别是什么呢" aria-hidden="true">#</a> 1.13. 执行 execute()方法和 submit()方法的区别是什么呢?</h2><ol><li>execute()方法用于提交不需要返回值的任务, 所以无法判断任务是否被线程池执行成功与否;</li><li>submit()方法用于提交需要返回值的任务. 线程池会返回一个 Future 类型的对象, 通过这个 Future 对象可以判断任务是否执行成功, 并且可以通过 Future 的 get()方法来获取返回值, get()方法会阻塞当前线程直到任务完成, 而使用 get(longtimeout, TimeUnitunit)方法则会阻塞当前线程一段时间后立即返回, 这时候有可能任务没有执行完.</li></ol><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token comment">// submit</span>\n<span class="token keyword">public</span> <span class="token class-name">Future</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span></span> <span class="token function">submit</span><span class="token punctuation">(</span><span class="token class-name">Runnable</span> task<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">if</span> <span class="token punctuation">(</span>task <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">NullPointerException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token class-name">RunnableFuture</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Void</span><span class="token punctuation">&gt;</span></span> ftask <span class="token operator">=</span> <span class="token function">newTaskFor</span><span class="token punctuation">(</span>task<span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token function">execute</span><span class="token punctuation">(</span>ftask<span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token keyword">return</span> ftask<span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n\n<span class="token comment">// execute</span>\n<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">execute</span><span class="token punctuation">(</span><span class="token class-name">Runnable</span> command<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br></div></div><h2 id="_1-14-如何创建线程池" tabindex="-1"><a class="header-anchor" href="#_1-14-如何创建线程池" aria-hidden="true">#</a> 1.14. 如何创建线程池</h2><p>&lt;&lt;阿里巴巴 Java 开发手册&gt;&gt; 中强制线程池不允许使用 Executors 去创建, 而是通过 ThreadPoolExecutor 的方式, 这样的处理方式让写的同学更加明确线程池的运行规则, 规避资源耗尽的风险</p><p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-6/ThreadPoolExecutor构造方法.png" alt=""></p><h3 id="_1-14-1-通过-executor-框架的工具类-executors-来实现" tabindex="-1"><a class="header-anchor" href="#_1-14-1-通过-executor-框架的工具类-executors-来实现" aria-hidden="true">#</a> 1.14.1. 通过 Executor 框架的工具类 Executors 来实现</h3><p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-6/Executor框架的工具类.png" alt=""></p><ol><li>FixedThreadPool: 该方法返回一个固定线程数量的线程池. 该线程池中的线程数量始终不变. 当有一个新的任务提交时, 线程池中若有空闲线程, 则立即执行. 若没有, 则新的任务会被暂存在一个任务队列中, 待有线程空闲时, 便处理在任务队列中的任务.</li><li>SingleThreadExecutor: 方法返回一个只有一个线程的线程池. 若多余一个任务被提交到该线程池, 任务会被保存在一个任务队列中, 待线程空闲, 按先入先出的顺序执行队列中的任务.</li><li>CachedThreadPool: 该方法返回一个可根据实际情况调整线程数量的线程池. 线程池的线程数量不确定, 但若有空闲线程可以复用, 则会优先使用可复用的线程. 若所有线程均在工作, 又有新的任务提交, 则会创建新的线程处理任务. 所有线程在当前任务执行完毕后, 将返回线程池进行复用.</li></ol><h4 id="_1-14-1-1-executors-返回线程池对象的弊端" tabindex="-1"><a class="header-anchor" href="#_1-14-1-1-executors-返回线程池对象的弊端" aria-hidden="true">#</a> 1.14.1.1. Executors 返回线程池对象的弊端</h4><ol><li>FixedThreadPool 和 SingleThreadExecutor: 允许请求的队列长度为 Integer. MAX_VALUE, 可能堆积大量的请求, 从而导致 OOM.</li><li>CachedThreadPool 和 ScheduledThreadPool: 允许创建的线程数量为 Integer. MAX_VALUE, 可能会创建大量线程, 从而导致 OOM.</li></ol><h3 id="_1-14-2-threadpoolexecutor-类分析" tabindex="-1"><a class="header-anchor" href="#_1-14-2-threadpoolexecutor-类分析" aria-hidden="true">#</a> 1.14.2. ThreadPoolExecutor 类分析</h3><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token doc-comment comment">/**\n * 用给定的初始参数创建一个新的ThreadPoolExecutor.\n */</span>\n<span class="token keyword">public</span> <span class="token class-name">ThreadPoolExecutor</span><span class="token punctuation">(</span><span class="token keyword">int</span> corePoolSize<span class="token punctuation">,</span>\n                      <span class="token keyword">int</span> maximumPoolSize<span class="token punctuation">,</span>\n                      <span class="token keyword">long</span> keepAliveTime<span class="token punctuation">,</span>\n                      <span class="token class-name">TimeUnit</span> unit<span class="token punctuation">,</span>\n                      <span class="token class-name">BlockingQueue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Runnable</span><span class="token punctuation">&gt;</span></span> workQueue<span class="token punctuation">,</span>\n                      <span class="token class-name">ThreadFactory</span> threadFactory<span class="token punctuation">,</span>\n                      <span class="token class-name">RejectedExecutionHandler</span> handler<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">if</span> <span class="token punctuation">(</span>corePoolSize <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token operator">||</span>\n        maximumPoolSize <span class="token operator">&lt;=</span> <span class="token number">0</span> <span class="token operator">||</span>\n        maximumPoolSize <span class="token operator">&lt;</span> corePoolSize <span class="token operator">||</span>\n        keepAliveTime <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>\n            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalArgumentException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token keyword">if</span> <span class="token punctuation">(</span>workQueue <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">||</span> threadFactory <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">||</span> handler <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>\n        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">NullPointerException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token keyword">this</span><span class="token punctuation">.</span>corePoolSize <span class="token operator">=</span> corePoolSize<span class="token punctuation">;</span>\n    <span class="token keyword">this</span><span class="token punctuation">.</span>maximumPoolSize <span class="token operator">=</span> maximumPoolSize<span class="token punctuation">;</span>\n    <span class="token keyword">this</span><span class="token punctuation">.</span>workQueue <span class="token operator">=</span> workQueue<span class="token punctuation">;</span>\n    <span class="token keyword">this</span><span class="token punctuation">.</span>keepAliveTime <span class="token operator">=</span> unit<span class="token punctuation">.</span><span class="token function">toNanos</span><span class="token punctuation">(</span>keepAliveTime<span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token keyword">this</span><span class="token punctuation">.</span>threadFactory <span class="token operator">=</span> threadFactory<span class="token punctuation">;</span>\n    <span class="token keyword">this</span><span class="token punctuation">.</span>handler <span class="token operator">=</span> handler<span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br></div></div><h3 id="_1-14-3-threadpoolexecutor-构造函数重要参数分析" tabindex="-1"><a class="header-anchor" href="#_1-14-3-threadpoolexecutor-构造函数重要参数分析" aria-hidden="true">#</a> 1.14.3. threadPoolExecutor 构造函数重要参数分析</h3><h4 id="_1-14-3-1-threadpoolexecutor-3-个最重要的参数" tabindex="-1"><a class="header-anchor" href="#_1-14-3-1-threadpoolexecutor-3-个最重要的参数" aria-hidden="true">#</a> 1.14.3.1. ThreadPoolExecutor 3 个最重要的参数</h4><ol><li>corePoolSize: 核心线程数线程数定义了最小可以同时运行的线程数量.</li><li>maximumPoolSize: 当队列中存放的任务达到队列容量的时候, 当前可以同时运行的线程数量变为最大线程数.</li><li>workQueue: 当新任务来的时候会先判断当前运行的线程数量是否达到核心线程数, 如果达到的话, 新任务就会被存放在队列中.</li></ol><h4 id="_1-14-3-2-threadpoolexecutor-其他常见参数" tabindex="-1"><a class="header-anchor" href="#_1-14-3-2-threadpoolexecutor-其他常见参数" aria-hidden="true">#</a> 1.14.3.2. ThreadPoolExecutor 其他常见参数</h4><ol><li>keepAliveTime: 当线程池中的线程数量大于 corePoolSize 的时候, 如果这时没有新的任务提交, 核心线程外的线程不会立即销毁, 而是会等待, 直到等待的时间超过了 keepAliveTime 才会被回收销毁;</li><li>unit: keepAliveTime 参数的时间单位.</li><li>threadFactory: executor 创建新线程的时候会用到.</li><li>handler: 饱和策略. 关于饱和策略下面单独介绍一下.</li></ol><h3 id="_1-14-4-hreadpoolexecutor-饱和策略" tabindex="-1"><a class="header-anchor" href="#_1-14-4-hreadpoolexecutor-饱和策略" aria-hidden="true">#</a> 1.14.4. hreadPoolExecutor 饱和策略</h3><p>如果当前同时运行的线程数量达到最大线程数量并且队列也已经被放满了任务时, ThreadPoolTaskExecutor 可以定义的一些策略:</p><ol><li>ThreadPoolExecutor.AbortPolicy: 抛出 RejectedExecutionException 来拒绝新任务的处理.</li><li>ThreadPoolExecutor.CallerRunsPolicy: 调用执行自己的线程运行任务, 也就是直接在调用 execute 方法的线程中运行(run)被拒绝的任务, 如果执行程序已关闭, 则会丢弃该任务. 因此这种策略会降低对于新任务提交速度, 影响程序的整体性能. 如果您的应用程序可以承受此延迟并且你要求任何一个任务请求都要被执行的话, 你可以选择这个策略.</li><li>ThreadPoolExecutor.DiscardPolicy: 不处理新任务, 直接丢弃掉.</li><li>ThreadPoolExecutor.DiscardOldestPolicy: 此策略将丢弃最早的未处理的任务请求.</li></ol><h3 id="_1-14-5-线程池原理分析" tabindex="-1"><a class="header-anchor" href="#_1-14-5-线程池原理分析" aria-hidden="true">#</a> 1.14.5. 线程池原理分析</h3><p><img src="https://static001.geekbang.org/infoq/07/07fb9ec57f20d5d505261bc6af88236b.png" alt=""></p><blockquote><p>比如: 我们在代码中模拟了 10 个任务, 我们配置的核心线程数为 5 , 等待队列容量为 100 , 所以每次只可能存在 5 个任务同时执行, 剩下的 5 个任务会被放到等待队列中去. 当前的 5 个任务中如果有任务被执行完了, 线程池就会去拿新的任务执行</p></blockquote><p>重点分析一下 execute 方法, 一般使用 executor.execute(worker)来提交一个任务到线程池中</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token comment">// 存放线程池的运行状态 (runState) 和线程池内有效线程的数量 (workerCount)</span>\n<span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">AtomicInteger</span> ctl <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">AtomicInteger</span><span class="token punctuation">(</span><span class="token function">ctlOf</span><span class="token punctuation">(</span>RUNNING<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n<span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">workerCountOf</span><span class="token punctuation">(</span><span class="token keyword">int</span> c<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">return</span> c <span class="token operator">&amp;</span> CAPACITY<span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n\n<span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">BlockingQueue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Runnable</span><span class="token punctuation">&gt;</span></span> workQueue<span class="token punctuation">;</span>\n\n<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">execute</span><span class="token punctuation">(</span><span class="token class-name">Runnable</span> command<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token comment">// 如果任务为null, 则抛出异常.</span>\n    <span class="token keyword">if</span> <span class="token punctuation">(</span>command <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>\n        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">NullPointerException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token comment">// ctl 中保存的线程池当前的一些状态信息</span>\n    <span class="token keyword">int</span> c <span class="token operator">=</span> ctl<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n    <span class="token comment">//  下面会涉及到 3 步 操作</span>\n    <span class="token comment">// 1.首先判断当前线程池中执行的任务数量是否小于 corePoolSize</span>\n    <span class="token comment">// 如果小于的话, 通过addWorker(command, true)新建一个线程, 并将任务(command)添加到该线程中; 然后, 启动该线程从而执行任务.</span>\n    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">workerCountOf</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span> <span class="token operator">&lt;</span> corePoolSize<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">addWorker</span><span class="token punctuation">(</span>command<span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">)</span>\n            <span class="token keyword">return</span><span class="token punctuation">;</span>\n        c <span class="token operator">=</span> ctl<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n    <span class="token comment">// 2.如果当前执行的任务数量大于等于 corePoolSize 的时候就会走到这里</span>\n    <span class="token comment">// 通过 isRunning 方法判断线程池状态, 线程池处于 RUNNING 状态才会被并且队列可以加入任务, 该任务才会被加入进去</span>\n    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isRunning</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> workQueue<span class="token punctuation">.</span><span class="token function">offer</span><span class="token punctuation">(</span>command<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        <span class="token keyword">int</span> recheck <span class="token operator">=</span> ctl<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n        <span class="token comment">// 再次获取线程池状态, 如果线程池状态不是 RUNNING 状态就需要从任务队列中移除任务, 并尝试判断线程是否全部执行完毕. 同时执行拒绝策略.</span>\n        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">isRunning</span><span class="token punctuation">(</span>recheck<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token function">remove</span><span class="token punctuation">(</span>command<span class="token punctuation">)</span><span class="token punctuation">)</span>\n            <span class="token function">reject</span><span class="token punctuation">(</span>command<span class="token punctuation">)</span><span class="token punctuation">;</span>\n            <span class="token comment">// 如果当前线程池为空就新创建一个线程并执行.</span>\n        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">workerCountOf</span><span class="token punctuation">(</span>recheck<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>\n            <span class="token function">addWorker</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n    <span class="token comment">//3. 通过addWorker(command, false)新建一个线程, 并将任务(command)添加到该线程中; 然后, 启动该线程从而执行任务.</span>\n    <span class="token comment">//如果addWorker(command, false)执行失败, 则通过reject()执行相应的拒绝策略的内容.</span>\n    <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">addWorker</span><span class="token punctuation">(</span>command<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">)</span>\n        <span class="token function">reject</span><span class="token punctuation">(</span>command<span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br><span class="line-number">40</span><br><span class="line-number">41</span><br></div></div><h2 id="_1-15-介绍一下-atomic-原子类" tabindex="-1"><a class="header-anchor" href="#_1-15-介绍一下-atomic-原子类" aria-hidden="true">#</a> 1.15. 介绍一下 Atomic 原子类</h2><p>原子类是具有原子操作特征的类. Atomic 是指一个操作是不可中断的. 即使是在多个线程一起执行的时候, 一个操作一旦开始, 就不会被其他线程干扰.</p><h2 id="_1-16-juc-包中的原子类是哪-4-类" tabindex="-1"><a class="header-anchor" href="#_1-16-juc-包中的原子类是哪-4-类" aria-hidden="true">#</a> 1.16. JUC 包中的原子类是哪 4 类?</h2><h3 id="_1-16-1-基本类型" tabindex="-1"><a class="header-anchor" href="#_1-16-1-基本类型" aria-hidden="true">#</a> 1.16.1. 基本类型</h3><p>使用原子的方式更新基本类型</p><ol><li>AtomicInteger: 整形原子类</li><li>AtomicLong: 长整型原子类</li><li>AtomicBoolean: 布尔型原子类</li></ol><h3 id="_1-16-2-数组类型" tabindex="-1"><a class="header-anchor" href="#_1-16-2-数组类型" aria-hidden="true">#</a> 1.16.2. 数组类型</h3><p>使用原子的方式更新数组里的某个元素</p><ol><li>AtomicIntegerArray: 整形数组原子类</li><li>AtomicLongArray: 长整形数组原子类</li><li>AtomicReferenceArray: 引用类型数组原子类</li></ol><h3 id="_1-16-3-引用类型" tabindex="-1"><a class="header-anchor" href="#_1-16-3-引用类型" aria-hidden="true">#</a> 1.16.3. 引用类型</h3><ol><li>AtomicReference: 引用类型原子类</li><li>AtomicStampedReference: 原子更新带有版本号的引用类型. 该类将整数值与引用关联起来, 可用于解决原子的更新数据和数据的版本号, 可以解决使用 CAS 进行原子更新时可能出现的 ABA 问题.</li><li>AtomicMarkableReference: 原子更新带有标记位的引用类型</li></ol><h3 id="_1-16-4-对象的属性修改类型" tabindex="-1"><a class="header-anchor" href="#_1-16-4-对象的属性修改类型" aria-hidden="true">#</a> 1.16.4. 对象的属性修改类型</h3><ol><li>AtomicIntegerFieldUpdater: 原子更新整形字段的更新器</li><li>AtomicLongFieldUpdater: 原子更新长整形字段的更新器</li><li>AtomicReferenceFieldUpdater: 原子更新引用类型字段的更新器</li></ol>',90),p={},t=(0,s(3744).Z)(p,[["render",function(n,a){return e}]])},3744:(n,a)=>{a.Z=(n,a)=>{const s=n.__vccOpts||n;for(const[n,e]of a)s[n]=e;return s}}}]);