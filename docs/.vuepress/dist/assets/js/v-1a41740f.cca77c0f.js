"use strict";(self.webpackChunkaudition=self.webpackChunkaudition||[]).push([[83],{4646:(e,a,t)=>{t.r(a),t.d(a,{data:()=>i});const i={key:"v-1a41740f",path:"/spring/mybatis.html",title:"1. mybatis",lang:"en-EN",frontmatter:{},excerpt:"",headers:[{level:2,title:"1.1. #{}和${}的区别是什么?",slug:"_1-1-和-的区别是什么",children:[]},{level:2,title:"1.2. Xml 映射文件中, 除了常见的 select|insert|update|delete 标签之外, 还有哪些标签?",slug:"_1-2-xml-映射文件中-除了常见的-select-insert-update-delete-标签之外-还有哪些标签",children:[]},{level:2,title:"1.3. 通常一个 Xml 映射文件, 都会写一个 Dao 接口与之对应, 请问, 这个 Dao 接口的工作原理是什么? Dao 接口里的方法, 参数不同时, 方法能重载吗?",slug:"_1-3-通常一个-xml-映射文件-都会写一个-dao-接口与之对应-请问-这个-dao-接口的工作原理是什么-dao-接口里的方法-参数不同时-方法能重载吗",children:[]},{level:2,title:"1.4. MyBatis 是如何进行分页的? 分页插件的原理是什么?",slug:"_1-4-mybatis-是如何进行分页的-分页插件的原理是什么",children:[]},{level:2,title:"1.5. 简述 MyBatis 的插件运行原理, 以及如何编写一个插件",slug:"_1-5-简述-mybatis-的插件运行原理-以及如何编写一个插件",children:[]},{level:2,title:"1.6. MyBatis 动态 sql 是做什么的? 都有哪些动态 sql? 能简述一下动态 sql 的执行原理不?",slug:"_1-6-mybatis-动态-sql-是做什么的-都有哪些动态-sql-能简述一下动态-sql-的执行原理不",children:[]},{level:2,title:"1.7. MyBatis 是如何将 sql 执行结果封装为目标对象并返回的? 都有哪些映射形式?",slug:"_1-7-mybatis-是如何将-sql-执行结果封装为目标对象并返回的-都有哪些映射形式",children:[]},{level:2,title:"1.8. MyBatis 是否支持延迟加载? 如果支持, 它的实现原理是什么?",slug:"_1-8-mybatis-是否支持延迟加载-如果支持-它的实现原理是什么",children:[]},{level:2,title:"1.9. MyBatis 的 Xml 映射文件中, 不同的 Xml 映射文件, id 是否可以重复?",slug:"_1-9-mybatis-的-xml-映射文件中-不同的-xml-映射文件-id-是否可以重复",children:[]},{level:2,title:"1.10. MyBatis 中如何执行批处理?",slug:"_1-10-mybatis-中如何执行批处理",children:[]},{level:2,title:"1.11. MyBatis 都有哪些 Executor 执行器? 它们之间的区别是什么?",slug:"_1-11-mybatis-都有哪些-executor-执行器-它们之间的区别是什么",children:[]},{level:2,title:"1.12. MyBatis 中如何指定使用哪一种 Executor 执行器?",slug:"_1-12-mybatis-中如何指定使用哪一种-executor-执行器",children:[]},{level:2,title:"1.13. MyBatis 是否可以映射 Enum 枚举类?",slug:"_1-13-mybatis-是否可以映射-enum-枚举类",children:[]},{level:2,title:"1.14. MyBatis 映射文件中, 如果 A 标签通过 include 引用了 B 标签的内容, 请问, B 标签能否定义在 A 标签的后面, 还是说必须定义在 A 标签的前面?",slug:"_1-14-mybatis-映射文件中-如果-a-标签通过-include-引用了-b-标签的内容-请问-b-标签能否定义在-a-标签的后面-还是说必须定义在-a-标签的前面",children:[]},{level:2,title:"1.15. 为什么说 MyBatis 是半自动 ORM 映射工具? 它与全自动的区别在哪里?",slug:"_1-15-为什么说-mybatis-是半自动-orm-映射工具-它与全自动的区别在哪里",children:[]}],filePathRelative:"spring/mybatis.md",git:{updatedTime:164087111e4,contributors:[{name:"shorestraydog",email:"shorestraydog@protonmail.com",commits:6}]}}},4335:(e,a,t)=>{t.r(a),t.d(a,{default:()=>s});const i=(0,t(6252).uE)('<h1 id="_1-mybatis" tabindex="-1"><a class="header-anchor" href="#_1-mybatis" aria-hidden="true">#</a> 1. mybatis</h1><h2 id="_1-1-和-的区别是什么" tabindex="-1"><a class="header-anchor" href="#_1-1-和-的区别是什么" aria-hidden="true">#</a> 1.1. #{}和${}的区别是什么?</h2><ol><li>${}是 Properties 文件中的变量占位符, 它可以用于标签属性值和 sql 内部, 属于静态文本替换, 比如${driver}会被静态替换为 com.mysql.jdbc. Driver.</li><li>#{}是 sql 的参数占位符, MyBatis 会将 sql 中的#{}替换为?号, 在 sql 执行前会使用 PreparedStatement 的参数设置方法, 按序给 sql 的?号占位符设置参数值</li></ol><h2 id="_1-2-xml-映射文件中-除了常见的-select-insert-update-delete-标签之外-还有哪些标签" tabindex="-1"><a class="header-anchor" href="#_1-2-xml-映射文件中-除了常见的-select-insert-update-delete-标签之外-还有哪些标签" aria-hidden="true">#</a> 1.2. Xml 映射文件中, 除了常见的 select|insert|update|delete 标签之外, 还有哪些标签?</h2><p>&lt;resultMap&gt; , &lt;parameterMap&gt; , &lt;sql&gt; , &lt;include&gt; , &lt;selectKey&gt; , 加上动态 sql 的 9 个标签, trim |where |set |foreach |if |choose |when |otherwise |bind 等, 其中 &lt;sql&gt; 为 sql 片段标签, 通过 &lt;include&gt; 标签引入 sql 片段,&lt;selectKey&gt; 为不支持自增的主键生成策略标签.</p><h2 id="_1-3-通常一个-xml-映射文件-都会写一个-dao-接口与之对应-请问-这个-dao-接口的工作原理是什么-dao-接口里的方法-参数不同时-方法能重载吗" tabindex="-1"><a class="header-anchor" href="#_1-3-通常一个-xml-映射文件-都会写一个-dao-接口与之对应-请问-这个-dao-接口的工作原理是什么-dao-接口里的方法-参数不同时-方法能重载吗" aria-hidden="true">#</a> 1.3. 通常一个 Xml 映射文件, 都会写一个 Dao 接口与之对应, 请问, 这个 Dao 接口的工作原理是什么? Dao 接口里的方法, 参数不同时, 方法能重载吗?</h2><p>Dao 接口, 就是人们常说的 Mapper 接口, 接口的全限名, 就是映射文件中的 namespace 的值, 接口的方法名, 就是映射文件中 MappedStatement 的 id 值, 接口方法内的参数, 就是传递给 sql 的参数. Mapper 接口是没有实现类的, 当调用接口方法时, 接口全限名+方法名拼接字符串作为 key 值, 可唯一定位一个 MappedStatement , 举例: com.mybatis3.mappers.StudentDao.findStudentById , 可以唯一找到 namespace 为 com.mybatis3.mappers. StudentDao 下面 id = findStudentById 的 MappedStatement.在 MyBatis 中, 每一个 &lt;select&gt; , &lt;insert&gt; , &lt;update&gt; , &lt;delete&gt; 标签, 都会被解析为一个 MappedStatement 对象.</p><p>Dao 接口里的方法可以重载, 但是 Mybatis 的 XML 里面的 ID 不允许重复.</p><p>Dao 接口的工作原理是 JDK 动态代理, MyBatis 运行时会使用 JDK 动态代理为 Dao 接口生成代理 proxy 对象, 代理对象 proxy 会拦截接口方法, 转而执行 MappedStatement 所代表的 sql, 然后将 sql 执行结果返回.</p><h2 id="_1-4-mybatis-是如何进行分页的-分页插件的原理是什么" tabindex="-1"><a class="header-anchor" href="#_1-4-mybatis-是如何进行分页的-分页插件的原理是什么" aria-hidden="true">#</a> 1.4. MyBatis 是如何进行分页的? 分页插件的原理是什么?</h2><ol><li>MyBatis 使用 RowBounds 对象进行分页, 它是针对 ResultSet 结果集执行的内存分页, 而非物理分页;</li><li>可以在 sql 内直接书写带有物理分页的参数来完成物理分页功能</li><li>也可以使用分页插件来完成物理分页.</li></ol><p>分页插件的基本原理是使用 MyBatis 提供的插件接口, 实现自定义插件, 在插件的拦截方法内拦截待执行的 sql, 然后重写 sql, 根据 dialect 方言, 添加对应的物理分页语句和物理分页参数.</p><h2 id="_1-5-简述-mybatis-的插件运行原理-以及如何编写一个插件" tabindex="-1"><a class="header-anchor" href="#_1-5-简述-mybatis-的插件运行原理-以及如何编写一个插件" aria-hidden="true">#</a> 1.5. 简述 MyBatis 的插件运行原理, 以及如何编写一个插件</h2><p>MyBatis 仅可以编写针对 ParameterHandler , ResultSetHandler , StatementHandler , Executor 这 4 种接口的插件, MyBatis 使用 JDK 的动态代理, 为需要拦截的接口生成代理对象以实现接口方法拦截功能, 每当执行这 4 种接口对象的方法时, 就会进入拦截方法, 具体就是 InvocationHandler 的 invoke() 方法, 当然, 只会拦截那些你指定需要拦截的方法.</p><p>实现 MyBatis 的 Interceptor 接口并复写 intercept() 方法, 然后在给插件编写注解, 指定要拦截哪一个接口的哪些方法即可, 记住, 别忘了在配置文件中配置你编写的插件.</p><h2 id="_1-6-mybatis-动态-sql-是做什么的-都有哪些动态-sql-能简述一下动态-sql-的执行原理不" tabindex="-1"><a class="header-anchor" href="#_1-6-mybatis-动态-sql-是做什么的-都有哪些动态-sql-能简述一下动态-sql-的执行原理不" aria-hidden="true">#</a> 1.6. MyBatis 动态 sql 是做什么的? 都有哪些动态 sql? 能简述一下动态 sql 的执行原理不?</h2><p>MyBatis 动态 sql 可以让我们在 Xml 映射文件内, 以标签的形式编写动态 sql, 完成逻辑判断和动态拼接 sql 的功能, MyBatis 提供了 9 种动态 sql 标签 trim|where|set|foreach|if|choose|when|otherwise|bind .</p><p>其执行原理为, 使用 OGNL 从 sql 参数对象中计算表达式的值, 根据表达式的值动态拼接 sql, 以此来完成动态 sql 的功能.</p><h2 id="_1-7-mybatis-是如何将-sql-执行结果封装为目标对象并返回的-都有哪些映射形式" tabindex="-1"><a class="header-anchor" href="#_1-7-mybatis-是如何将-sql-执行结果封装为目标对象并返回的-都有哪些映射形式" aria-hidden="true">#</a> 1.7. MyBatis 是如何将 sql 执行结果封装为目标对象并返回的? 都有哪些映射形式?</h2><p>第一种是使用 &lt;resultMap&gt; 标签, 逐一定义列名和对象属性名之间的映射关系.第二种是使用 sql 列的别名功能, 将列别名书写为对象属性名, 比如 T_NAME AS NAME, 对象属性名一般是 name, 小写, 但是列名不区分大小写, MyBatis 会忽略列名大小写, 智能找到与之对应对象属性名, 你甚至可以写成 T_NAME AS NaMe, MyBatis 一样可以正常工作.</p><p>有了列名与属性名的映射关系后, MyBatis 通过反射创建对象, 同时使用反射给对象的属性逐一赋值并返回, 那些找不到映射关系的属性, 是无法完成赋值的.</p><h2 id="_1-8-mybatis-是否支持延迟加载-如果支持-它的实现原理是什么" tabindex="-1"><a class="header-anchor" href="#_1-8-mybatis-是否支持延迟加载-如果支持-它的实现原理是什么" aria-hidden="true">#</a> 1.8. MyBatis 是否支持延迟加载? 如果支持, 它的实现原理是什么?</h2><p>MyBatis 仅支持 association 关联对象和 collection 关联集合对象的延迟加载, association 指的就是一对一, collection 指的就是一对多查询.在 MyBatis 配置文件中, 可以配置是否启用延迟加载 lazyLoadingEnabled=true|false.</p><p>它的原理是, 使用 CGLIB 创建目标对象的代理对象, 当调用目标方法时, 进入拦截器方法, 比如调用 a.getB().getName() , 拦截器 invoke() 方法发现 a.getB() 是 null 值, 那么就会单独发送事先保存好的查询关联 B 对象的 sql, 把 B 查询上来, 然后调用 a.setB(b), 于是 a 的对象 b 属性就有值了, 接着完成 a.getB().getName() 方法的调用.这就是延迟加载的基本原理.</p><p>当然了, 不光是 MyBatis, 几乎所有的包括 Hibernate, 支持延迟加载的原理都是一样的.</p><h2 id="_1-9-mybatis-的-xml-映射文件中-不同的-xml-映射文件-id-是否可以重复" tabindex="-1"><a class="header-anchor" href="#_1-9-mybatis-的-xml-映射文件中-不同的-xml-映射文件-id-是否可以重复" aria-hidden="true">#</a> 1.9. MyBatis 的 Xml 映射文件中, 不同的 Xml 映射文件, id 是否可以重复?</h2><p>不同的 Xml 映射文件, 如果配置了 namespace, 那么 id 可以重复; 如果没有配置 namespace, 那么 id 不能重复; 毕竟 namespace 不是必须的, 只是最佳实践而已.</p><p>原因就是 namespace+id 是作为 Map&lt;String, MappedStatement&gt; 的 key 使用的, 如果没有 namespace, 就剩下 id, 那么, id 重复会导致数据互相覆盖.有了 namespace, 自然 id 就可以重复, namespace 不同, namespace+id 自然也就不同.</p><h2 id="_1-10-mybatis-中如何执行批处理" tabindex="-1"><a class="header-anchor" href="#_1-10-mybatis-中如何执行批处理" aria-hidden="true">#</a> 1.10. MyBatis 中如何执行批处理?</h2><p>使用 BatchExecutor 完成批处理.</p><h2 id="_1-11-mybatis-都有哪些-executor-执行器-它们之间的区别是什么" tabindex="-1"><a class="header-anchor" href="#_1-11-mybatis-都有哪些-executor-执行器-它们之间的区别是什么" aria-hidden="true">#</a> 1.11. MyBatis 都有哪些 Executor 执行器? 它们之间的区别是什么?</h2><p>MyBatis 有三种基本的 Executor 执行器, SimpleExecutor , ReuseExecutor , BatchExecutor .</p><ol><li>SimpleExecutor: 每执行一次 update 或 select, 就开启一个 Statement 对象, 用完立刻关闭 Statement 对象.</li><li>ReuseExecutor: 执行 update 或 select, 以 sql 作为 key 查找 Statement 对象, 存在就使用, 不存在就创建, 用完后, 不关闭 Statement 对象, 而是放置于 Map&lt;String, Statement&gt;内, 供下一次使用.简言之, 就是重复使用 Statement 对象.</li><li>BatchExecutor: 执行 update(没有 select, JDBC 批处理不支持 select), 将所有 sql 都添加到批处理中(addBatch()), 等待统一执行(executeBatch()), 它缓存了多个 Statement 对象, 每个 Statement 对象都是 addBatch()完毕后, 等待逐一执行 executeBatch()批处理.与 JDBC 批处理相同.</li></ol><p>作用范围: Executor 的这些特点, 都严格限制在 SqlSession 生命周期范围内.</p><h2 id="_1-12-mybatis-中如何指定使用哪一种-executor-执行器" tabindex="-1"><a class="header-anchor" href="#_1-12-mybatis-中如何指定使用哪一种-executor-执行器" aria-hidden="true">#</a> 1.12. MyBatis 中如何指定使用哪一种 Executor 执行器?</h2><p>默认的执行器是 SimplExcutor, 在 MyBatis 配置文件中, 可以指定默认的 ExecutorType 执行器类型, 也可以手动给 DefaultSqlSessionFactory 的创建 SqlSession 的方法传递 ExecutorType 类型参数.</p><h2 id="_1-13-mybatis-是否可以映射-enum-枚举类" tabindex="-1"><a class="header-anchor" href="#_1-13-mybatis-是否可以映射-enum-枚举类" aria-hidden="true">#</a> 1.13. MyBatis 是否可以映射 Enum 枚举类?</h2><p>MyBatis 可以映射枚举类, 不单可以映射枚举类, MyBatis 可以映射任何对象到表的一列上.映射方式为自定义一个 TypeHandler, 实现 TypeHandler 的 setParameter() 和 getResult() 接口方法. TypeHandler 有两个作用, 一是完成从 javaType 至 jdbcType 的转换, 二是完成 jdbcType 至 javaType 的转换, 体现为 setParameter() 和 getResult() 两个方法, 分别代表设置 sql 问号占位符参数和获取列查询结果.</p><h2 id="_1-14-mybatis-映射文件中-如果-a-标签通过-include-引用了-b-标签的内容-请问-b-标签能否定义在-a-标签的后面-还是说必须定义在-a-标签的前面" tabindex="-1"><a class="header-anchor" href="#_1-14-mybatis-映射文件中-如果-a-标签通过-include-引用了-b-标签的内容-请问-b-标签能否定义在-a-标签的后面-还是说必须定义在-a-标签的前面" aria-hidden="true">#</a> 1.14. MyBatis 映射文件中, 如果 A 标签通过 include 引用了 B 标签的内容, 请问, B 标签能否定义在 A 标签的后面, 还是说必须定义在 A 标签的前面?</h2><p>虽然 MyBatis 解析 Xml 映射文件是按照顺序解析的, 但是, 被引用的 B 标签依然可以定义在任何地方, MyBatis 都可以正确识别.</p><p>原理是, MyBatis 解析 A 标签, 发现 A 标签引用了 B 标签, 但是 B 标签尚未解析到, 尚不存在, 此时, MyBatis 会将 A 标签标记为未解析状态, 然后继续解析余下的标签, 包含 B 标签, 待所有标签解析完毕, MyBatis 会重新解析那些被标记为未解析的标签, 此时再解析 A 标签时, B 标签已经存在, A 标签也就可以正常解析完成了.</p><h2 id="_1-15-为什么说-mybatis-是半自动-orm-映射工具-它与全自动的区别在哪里" tabindex="-1"><a class="header-anchor" href="#_1-15-为什么说-mybatis-是半自动-orm-映射工具-它与全自动的区别在哪里" aria-hidden="true">#</a> 1.15. 为什么说 MyBatis 是半自动 ORM 映射工具? 它与全自动的区别在哪里?</h2><ol><li>MyBatis 在查询关联对象或关联集合对象时, 需要手动编写 sql 来完成, 所以为半自动 ORM 映射工具</li><li>Hibernate 属于全自动 ORM 映射工具, 使用 Hibernate 查询关联对象或者关联集合对象时, 可以根据对象关系模型直接获取, 所以它是全自动的.</li></ol>',43),l={},s=(0,t(3744).Z)(l,[["render",function(e,a){return i}]])},3744:(e,a)=>{a.Z=(e,a)=>{const t=e.__vccOpts||e;for(const[e,i]of a)t[e]=i;return t}}}]);