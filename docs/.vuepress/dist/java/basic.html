<!DOCTYPE html>
<html lang="en-EN">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <meta name="generator" content="VuePress 2.0.0-beta.27">
    <title>1. Java 基础 | 努力！奋斗！</title><meta name="description" content="">
    <link rel="preload" href="/audition/assets/js/runtime~app.97b28792.js" as="script"><link rel="preload" href="/audition/assets/css/styles.81f20975.css" as="style"><link rel="preload" href="/audition/assets/js/812.cf73d600.js" as="script"><link rel="preload" href="/audition/assets/js/app.fa25ad15.js" as="script">
    <link rel="stylesheet" href="/audition/assets/css/styles.81f20975.css">
  </head>
  <body>
    <div id="app"><!--[--><div class="theme-container"><!--[--><header class="navbar"><div class="toggle-sidebar-button" title="toggle sidebar" aria-expanded="false" role="button" tabindex="0"><div class="icon" aria-hidden="true"><span></span><span></span><span></span></div></div><span><a href="/audition/" class=""><!----><span class="site-name can-hide">努力！奋斗！</span></a></span><div class="navbar-links-wrapper" style=""><!--[--><!--]--><nav class="navbar-links can-hide"><!--[--><div class="navbar-links-item"><a href="/audition/" class="nav-link" aria-label="home"><!--[--><!--]--> home <!--[--><!--]--></a></div><div class="navbar-links-item"><div class="dropdown-wrapper"><button class="dropdown-title" type="button" aria-label="java"><span class="title">java</span><span class="arrow down"></span></button><button class="mobile-dropdown-title" type="button" aria-label="java"><span class="title">java</span><span class="right arrow"></span></button><!--[--><ul style="display:none;" class="nav-dropdown"><!--[--><li class="dropdown-item"><a href="/audition/java/basic" class="nav-link router-link-active" aria-label="basic"><!--[--><!--]--> basic <!--[--><!--]--></a></li><li class="dropdown-item"><a href="/audition/java/collection" class="nav-link" aria-label="collection"><!--[--><!--]--> collection <!--[--><!--]--></a></li><li class="dropdown-item"><a href="/audition/java/multithreadingbasic" class="nav-link" aria-label="multithreadingbasic"><!--[--><!--]--> multithreadingbasic <!--[--><!--]--></a></li><li class="dropdown-item"><a href="/audition/java/multithreadingadvanced" class="nav-link" aria-label="multithreadingadvanced"><!--[--><!--]--> multithreadingadvanced <!--[--><!--]--></a></li><li class="dropdown-item"><a href="/audition/java/jvm" class="nav-link" aria-label="jvm"><!--[--><!--]--> jvm <!--[--><!--]--></a></li><!--]--></ul><!--]--></div></div><div class="navbar-links-item"><div class="dropdown-wrapper"><button class="dropdown-title" type="button" aria-label="spring"><span class="title">spring</span><span class="arrow down"></span></button><button class="mobile-dropdown-title" type="button" aria-label="spring"><span class="title">spring</span><span class="right arrow"></span></button><!--[--><ul style="display:none;" class="nav-dropdown"><!--[--><li class="dropdown-item"><a href="/audition/spring/springboot" class="nav-link" aria-label="springboot"><!--[--><!--]--> springboot <!--[--><!--]--></a></li><li class="dropdown-item"><a href="/audition/spring/mybatis" class="nav-link" aria-label="mybatis"><!--[--><!--]--> mybatis <!--[--><!--]--></a></li><!--]--></ul><!--]--></div></div><div class="navbar-links-item"><div class="dropdown-wrapper"><button class="dropdown-title" type="button" aria-label="springcloud"><span class="title">springcloud</span><span class="arrow down"></span></button><button class="mobile-dropdown-title" type="button" aria-label="springcloud"><span class="title">springcloud</span><span class="right arrow"></span></button><!--[--><ul style="display:none;" class="nav-dropdown"><!--[--><li class="dropdown-item"><a href="/audition/springcloud/nacos" class="nav-link" aria-label="nacos"><!--[--><!--]--> nacos <!--[--><!--]--></a></li><li class="dropdown-item"><a href="/audition/springcloud/summary" class="nav-link" aria-label="summary"><!--[--><!--]--> summary <!--[--><!--]--></a></li><!--]--></ul><!--]--></div></div><div class="navbar-links-item"><div class="dropdown-wrapper"><button class="dropdown-title" type="button" aria-label="mq"><span class="title">mq</span><span class="arrow down"></span></button><button class="mobile-dropdown-title" type="button" aria-label="mq"><span class="title">mq</span><span class="right arrow"></span></button><!--[--><ul style="display:none;" class="nav-dropdown"><!--[--><li class="dropdown-item"><a href="/audition/mq/summary" class="nav-link" aria-label="summary"><!--[--><!--]--> summary <!--[--><!--]--></a></li><li class="dropdown-item"><a href="/audition/mq/kafka" class="nav-link" aria-label="kafka"><!--[--><!--]--> kafka <!--[--><!--]--></a></li><li class="dropdown-item"><a href="/audition/mq/rocketmq" class="nav-link" aria-label="rocketmq"><!--[--><!--]--> rocketmq <!--[--><!--]--></a></li><!--]--></ul><!--]--></div></div><div class="navbar-links-item"><div class="dropdown-wrapper"><button class="dropdown-title" type="button" aria-label="database"><span class="title">database</span><span class="arrow down"></span></button><button class="mobile-dropdown-title" type="button" aria-label="database"><span class="title">database</span><span class="right arrow"></span></button><!--[--><ul style="display:none;" class="nav-dropdown"><!--[--><li class="dropdown-item"><a href="/audition/database/mysql" class="nav-link" aria-label="mysql"><!--[--><!--]--> mysql <!--[--><!--]--></a></li><li class="dropdown-item"><a href="/audition/database/redis" class="nav-link" aria-label="redis"><!--[--><!--]--> redis <!--[--><!--]--></a></li><!--]--></ul><!--]--></div></div><div class="navbar-links-item"><div class="dropdown-wrapper"><button class="dropdown-title" type="button" aria-label="distributed"><span class="title">distributed</span><span class="arrow down"></span></button><button class="mobile-dropdown-title" type="button" aria-label="distributed"><span class="title">distributed</span><span class="right arrow"></span></button><!--[--><ul style="display:none;" class="nav-dropdown"><!--[--><li class="dropdown-item"><a href="/audition/distributed/zookeeper" class="nav-link" aria-label="zookeeper"><!--[--><!--]--> zookeeper <!--[--><!--]--></a></li><li class="dropdown-item"><a href="/audition/distributed/dubbo" class="nav-link" aria-label="dubbo"><!--[--><!--]--> dubbo <!--[--><!--]--></a></li><!--]--></ul><!--]--></div></div><div class="navbar-links-item"><div class="dropdown-wrapper"><button class="dropdown-title" type="button" aria-label="additional"><span class="title">additional</span><span class="arrow down"></span></button><button class="mobile-dropdown-title" type="button" aria-label="additional"><span class="title">additional</span><span class="right arrow"></span></button><!--[--><ul style="display:none;" class="nav-dropdown"><!--[--><li class="dropdown-item"><a href="/audition/additional/linux" class="nav-link" aria-label="linux"><!--[--><!--]--> linux <!--[--><!--]--></a></li><!--]--></ul><!--]--></div></div><div class="navbar-links-item"><a href="/audition/interview/" class="nav-link" aria-label="interview"><!--[--><!--]--> interview <!--[--><!--]--></a></div><!--]--></nav><!--[--><!--]--><button class="toggle-dark-button" title="toggle dark mode"><svg style="" class="icon" focusable="false" viewBox="0 0 32 32"><path d="M16 12.005a4 4 0 1 1-4 4a4.005 4.005 0 0 1 4-4m0-2a6 6 0 1 0 6 6a6 6 0 0 0-6-6z" fill="currentColor"></path><path d="M5.394 6.813l1.414-1.415l3.506 3.506L8.9 10.318z" fill="currentColor"></path><path d="M2 15.005h5v2H2z" fill="currentColor"></path><path d="M5.394 25.197L8.9 21.691l1.414 1.415l-3.506 3.505z" fill="currentColor"></path><path d="M15 25.005h2v5h-2z" fill="currentColor"></path><path d="M21.687 23.106l1.414-1.415l3.506 3.506l-1.414 1.414z" fill="currentColor"></path><path d="M25 15.005h5v2h-5z" fill="currentColor"></path><path d="M21.687 8.904l3.506-3.506l1.414 1.415l-3.506 3.505z" fill="currentColor"></path><path d="M15 2.005h2v5h-2z" fill="currentColor"></path></svg><svg style="display:none;" class="icon" focusable="false" viewBox="0 0 32 32"><path d="M13.502 5.414a15.075 15.075 0 0 0 11.594 18.194a11.113 11.113 0 0 1-7.975 3.39c-.138 0-.278.005-.418 0a11.094 11.094 0 0 1-3.2-21.584M14.98 3a1.002 1.002 0 0 0-.175.016a13.096 13.096 0 0 0 1.825 25.981c.164.006.328 0 .49 0a13.072 13.072 0 0 0 10.703-5.555a1.01 1.01 0 0 0-.783-1.565A13.08 13.08 0 0 1 15.89 4.38A1.015 1.015 0 0 0 14.98 3z" fill="currentColor"></path></svg></button><!----></div></header><!--]--><div class="sidebar-mask"></div><!--[--><aside class="sidebar"><nav class="navbar-links"><!--[--><div class="navbar-links-item"><a href="/audition/" class="nav-link" aria-label="home"><!--[--><!--]--> home <!--[--><!--]--></a></div><div class="navbar-links-item"><div class="dropdown-wrapper"><button class="dropdown-title" type="button" aria-label="java"><span class="title">java</span><span class="arrow down"></span></button><button class="mobile-dropdown-title" type="button" aria-label="java"><span class="title">java</span><span class="right arrow"></span></button><!--[--><ul style="display:none;" class="nav-dropdown"><!--[--><li class="dropdown-item"><a href="/audition/java/basic" class="nav-link router-link-active" aria-label="basic"><!--[--><!--]--> basic <!--[--><!--]--></a></li><li class="dropdown-item"><a href="/audition/java/collection" class="nav-link" aria-label="collection"><!--[--><!--]--> collection <!--[--><!--]--></a></li><li class="dropdown-item"><a href="/audition/java/multithreadingbasic" class="nav-link" aria-label="multithreadingbasic"><!--[--><!--]--> multithreadingbasic <!--[--><!--]--></a></li><li class="dropdown-item"><a href="/audition/java/multithreadingadvanced" class="nav-link" aria-label="multithreadingadvanced"><!--[--><!--]--> multithreadingadvanced <!--[--><!--]--></a></li><li class="dropdown-item"><a href="/audition/java/jvm" class="nav-link" aria-label="jvm"><!--[--><!--]--> jvm <!--[--><!--]--></a></li><!--]--></ul><!--]--></div></div><div class="navbar-links-item"><div class="dropdown-wrapper"><button class="dropdown-title" type="button" aria-label="spring"><span class="title">spring</span><span class="arrow down"></span></button><button class="mobile-dropdown-title" type="button" aria-label="spring"><span class="title">spring</span><span class="right arrow"></span></button><!--[--><ul style="display:none;" class="nav-dropdown"><!--[--><li class="dropdown-item"><a href="/audition/spring/springboot" class="nav-link" aria-label="springboot"><!--[--><!--]--> springboot <!--[--><!--]--></a></li><li class="dropdown-item"><a href="/audition/spring/mybatis" class="nav-link" aria-label="mybatis"><!--[--><!--]--> mybatis <!--[--><!--]--></a></li><!--]--></ul><!--]--></div></div><div class="navbar-links-item"><div class="dropdown-wrapper"><button class="dropdown-title" type="button" aria-label="springcloud"><span class="title">springcloud</span><span class="arrow down"></span></button><button class="mobile-dropdown-title" type="button" aria-label="springcloud"><span class="title">springcloud</span><span class="right arrow"></span></button><!--[--><ul style="display:none;" class="nav-dropdown"><!--[--><li class="dropdown-item"><a href="/audition/springcloud/nacos" class="nav-link" aria-label="nacos"><!--[--><!--]--> nacos <!--[--><!--]--></a></li><li class="dropdown-item"><a href="/audition/springcloud/summary" class="nav-link" aria-label="summary"><!--[--><!--]--> summary <!--[--><!--]--></a></li><!--]--></ul><!--]--></div></div><div class="navbar-links-item"><div class="dropdown-wrapper"><button class="dropdown-title" type="button" aria-label="mq"><span class="title">mq</span><span class="arrow down"></span></button><button class="mobile-dropdown-title" type="button" aria-label="mq"><span class="title">mq</span><span class="right arrow"></span></button><!--[--><ul style="display:none;" class="nav-dropdown"><!--[--><li class="dropdown-item"><a href="/audition/mq/summary" class="nav-link" aria-label="summary"><!--[--><!--]--> summary <!--[--><!--]--></a></li><li class="dropdown-item"><a href="/audition/mq/kafka" class="nav-link" aria-label="kafka"><!--[--><!--]--> kafka <!--[--><!--]--></a></li><li class="dropdown-item"><a href="/audition/mq/rocketmq" class="nav-link" aria-label="rocketmq"><!--[--><!--]--> rocketmq <!--[--><!--]--></a></li><!--]--></ul><!--]--></div></div><div class="navbar-links-item"><div class="dropdown-wrapper"><button class="dropdown-title" type="button" aria-label="database"><span class="title">database</span><span class="arrow down"></span></button><button class="mobile-dropdown-title" type="button" aria-label="database"><span class="title">database</span><span class="right arrow"></span></button><!--[--><ul style="display:none;" class="nav-dropdown"><!--[--><li class="dropdown-item"><a href="/audition/database/mysql" class="nav-link" aria-label="mysql"><!--[--><!--]--> mysql <!--[--><!--]--></a></li><li class="dropdown-item"><a href="/audition/database/redis" class="nav-link" aria-label="redis"><!--[--><!--]--> redis <!--[--><!--]--></a></li><!--]--></ul><!--]--></div></div><div class="navbar-links-item"><div class="dropdown-wrapper"><button class="dropdown-title" type="button" aria-label="distributed"><span class="title">distributed</span><span class="arrow down"></span></button><button class="mobile-dropdown-title" type="button" aria-label="distributed"><span class="title">distributed</span><span class="right arrow"></span></button><!--[--><ul style="display:none;" class="nav-dropdown"><!--[--><li class="dropdown-item"><a href="/audition/distributed/zookeeper" class="nav-link" aria-label="zookeeper"><!--[--><!--]--> zookeeper <!--[--><!--]--></a></li><li class="dropdown-item"><a href="/audition/distributed/dubbo" class="nav-link" aria-label="dubbo"><!--[--><!--]--> dubbo <!--[--><!--]--></a></li><!--]--></ul><!--]--></div></div><div class="navbar-links-item"><div class="dropdown-wrapper"><button class="dropdown-title" type="button" aria-label="additional"><span class="title">additional</span><span class="arrow down"></span></button><button class="mobile-dropdown-title" type="button" aria-label="additional"><span class="title">additional</span><span class="right arrow"></span></button><!--[--><ul style="display:none;" class="nav-dropdown"><!--[--><li class="dropdown-item"><a href="/audition/additional/linux" class="nav-link" aria-label="linux"><!--[--><!--]--> linux <!--[--><!--]--></a></li><!--]--></ul><!--]--></div></div><div class="navbar-links-item"><a href="/audition/interview/" class="nav-link" aria-label="interview"><!--[--><!--]--> interview <!--[--><!--]--></a></div><!--]--></nav><!--[--><!--]--><ul class="sidebar-links"><!--[--><!--[--><p class="sidebar-heading sidebar-item active">java</p><ul class=""><li><!--[--><a aria-current="page" href="/audition/java/basic.html" class="router-link-active router-link-exact-active nav-link router-link-active sidebar-item active" aria-label="1. Java 基础"><!--[--><!--]--> 1. Java 基础 <!--[--><!--]--></a><ul class="sidebar-sub-items"><li><!--[--><a aria-current="page" href="/audition/java/basic.html#_1-1-面向对象和面向过程的区别" class="router-link-active router-link-exact-active nav-link sidebar-item" aria-label="1.1. 面向对象和面向过程的区别"><!--[--><!--]--> 1.1. 面向对象和面向过程的区别 <!--[--><!--]--></a><!----><!--]--></li><li><!--[--><a aria-current="page" href="/audition/java/basic.html#_1-2-java-语言有哪些特点" class="router-link-active router-link-exact-active nav-link sidebar-item" aria-label="1.2. Java 语言有哪些特点？"><!--[--><!--]--> 1.2. Java 语言有哪些特点？ <!--[--><!--]--></a><!----><!--]--></li><li><!--[--><a aria-current="page" href="/audition/java/basic.html#_1-3-jvm" class="router-link-active router-link-exact-active nav-link sidebar-item" aria-label="1.3. JVM"><!--[--><!--]--> 1.3. JVM <!--[--><!--]--></a><ul class="sidebar-sub-items"><li><!--[--><a aria-current="page" href="/audition/java/basic.html#_1-3-1-什么是字节码-采用字节码的好处是什么" class="router-link-active router-link-exact-active nav-link sidebar-item" aria-label="1.3.1. 什么是字节码？采用字节码的好处是什么？"><!--[--><!--]--> 1.3.1. 什么是字节码？采用字节码的好处是什么？ <!--[--><!--]--></a><!----><!--]--></li></ul><!--]--></li><li><!--[--><a aria-current="page" href="/audition/java/basic.html#_1-4-jdk-和-jre" class="router-link-active router-link-exact-active nav-link sidebar-item" aria-label="1.4. JDK 和 JRE"><!--[--><!--]--> 1.4. JDK 和 JRE <!--[--><!--]--></a><!----><!--]--></li><li><!--[--><a aria-current="page" href="/audition/java/basic.html#_1-5-java-和-c-的区别" class="router-link-active router-link-exact-active nav-link sidebar-item" aria-label="1.5. Java 和 C++ 的区别？"><!--[--><!--]--> 1.5. Java 和 C++ 的区别？ <!--[--><!--]--></a><!----><!--]--></li><li><!--[--><a aria-current="page" href="/audition/java/basic.html#_1-6-字符型常量-char-和字符串常量-string-的区别" class="router-link-active router-link-exact-active nav-link sidebar-item" aria-label="1.6. 字符型常量 (char) 和字符串常量 (string) 的区别？"><!--[--><!--]--> 1.6. 字符型常量 (char) 和字符串常量 (string) 的区别？ <!--[--><!--]--></a><!----><!--]--></li><li><!--[--><a aria-current="page" href="/audition/java/basic.html#_1-7-构造器-constructor-是否可被-override" class="router-link-active router-link-exact-active nav-link sidebar-item" aria-label="1.7. 构造器 Constructor 是否可被 override?"><!--[--><!--]--> 1.7. 构造器 Constructor 是否可被 override? <!--[--><!--]--></a><!----><!--]--></li><li><!--[--><a aria-current="page" href="/audition/java/basic.html#_1-8-重载和重写的区别" class="router-link-active router-link-exact-active nav-link sidebar-item" aria-label="1.8. 重载和重写的区别"><!--[--><!--]--> 1.8. 重载和重写的区别 <!--[--><!--]--></a><ul class="sidebar-sub-items"><li><!--[--><a aria-current="page" href="/audition/java/basic.html#_1-8-1-重载" class="router-link-active router-link-exact-active nav-link sidebar-item" aria-label="1.8.1. 重载"><!--[--><!--]--> 1.8.1. 重载 <!--[--><!--]--></a><!----><!--]--></li><li><!--[--><a aria-current="page" href="/audition/java/basic.html#_1-8-2-重写" class="router-link-active router-link-exact-active nav-link sidebar-item" aria-label="1.8.2. 重写"><!--[--><!--]--> 1.8.2. 重写 <!--[--><!--]--></a><!----><!--]--></li></ul><!--]--></li><li><!--[--><a aria-current="page" href="/audition/java/basic.html#_1-9-java-面向对象编程三大特性-封装-继承-多态" class="router-link-active router-link-exact-active nav-link sidebar-item" aria-label="1.9. Java 面向对象编程三大特性：封装 继承 多态"><!--[--><!--]--> 1.9. Java 面向对象编程三大特性：封装 继承 多态 <!--[--><!--]--></a><ul class="sidebar-sub-items"><li><!--[--><a aria-current="page" href="/audition/java/basic.html#_1-9-1-封装" class="router-link-active router-link-exact-active nav-link sidebar-item" aria-label="1.9.1. 封装"><!--[--><!--]--> 1.9.1. 封装 <!--[--><!--]--></a><!----><!--]--></li><li><!--[--><a aria-current="page" href="/audition/java/basic.html#_1-9-2-继承" class="router-link-active router-link-exact-active nav-link sidebar-item" aria-label="1.9.2. 继承"><!--[--><!--]--> 1.9.2. 继承 <!--[--><!--]--></a><!----><!--]--></li><li><!--[--><a aria-current="page" href="/audition/java/basic.html#_1-9-3-多态" class="router-link-active router-link-exact-active nav-link sidebar-item" aria-label="1.9.3. 多态"><!--[--><!--]--> 1.9.3. 多态 <!--[--><!--]--></a><!----><!--]--></li></ul><!--]--></li><li><!--[--><a aria-current="page" href="/audition/java/basic.html#_1-10-string-stringbuffer-和-stringbuilder-的区别是什么-string-为什么是不可变的" class="router-link-active router-link-exact-active nav-link sidebar-item" aria-label="1.10. String StringBuffer 和 StringBuilder 的区别是什么？String 为什么是不可变的？"><!--[--><!--]--> 1.10. String StringBuffer 和 StringBuilder 的区别是什么？String 为什么是不可变的？ <!--[--><!--]--></a><ul class="sidebar-sub-items"><li><!--[--><a aria-current="page" href="/audition/java/basic.html#_1-10-1-可变性" class="router-link-active router-link-exact-active nav-link sidebar-item" aria-label="1.10.1. 可变性"><!--[--><!--]--> 1.10.1. 可变性 <!--[--><!--]--></a><!----><!--]--></li><li><!--[--><a aria-current="page" href="/audition/java/basic.html#_1-10-2-线程安全性" class="router-link-active router-link-exact-active nav-link sidebar-item" aria-label="1.10.2. 线程安全性"><!--[--><!--]--> 1.10.2. 线程安全性 <!--[--><!--]--></a><!----><!--]--></li><li><!--[--><a aria-current="page" href="/audition/java/basic.html#_1-10-3-性能" class="router-link-active router-link-exact-active nav-link sidebar-item" aria-label="1.10.3. 性能"><!--[--><!--]--> 1.10.3. 性能 <!--[--><!--]--></a><!----><!--]--></li><li><!--[--><a aria-current="page" href="/audition/java/basic.html#_1-10-4-对于三者使用的总结" class="router-link-active router-link-exact-active nav-link sidebar-item" aria-label="1.10.4. 对于三者使用的总结"><!--[--><!--]--> 1.10.4. 对于三者使用的总结 <!--[--><!--]--></a><!----><!--]--></li></ul><!--]--></li><li><!--[--><a aria-current="page" href="/audition/java/basic.html#_1-11-自动装箱与拆箱" class="router-link-active router-link-exact-active nav-link sidebar-item" aria-label="1.11. 自动装箱与拆箱"><!--[--><!--]--> 1.11. 自动装箱与拆箱 <!--[--><!--]--></a><!----><!--]--></li><li><!--[--><a aria-current="page" href="/audition/java/basic.html#_1-12-在一个静态方法内调用一个非静态成员为什么是非法的" class="router-link-active router-link-exact-active nav-link sidebar-item" aria-label="1.12. 在一个静态方法内调用一个非静态成员为什么是非法的？"><!--[--><!--]--> 1.12. 在一个静态方法内调用一个非静态成员为什么是非法的？ <!--[--><!--]--></a><!----><!--]--></li><li><!--[--><a aria-current="page" href="/audition/java/basic.html#_1-13-在-java-中定义一个不做事且没有参数的构造方法的作用" class="router-link-active router-link-exact-active nav-link sidebar-item" aria-label="1.13. 在 Java 中定义一个不做事且没有参数的构造方法的作用"><!--[--><!--]--> 1.13. 在 Java 中定义一个不做事且没有参数的构造方法的作用 <!--[--><!--]--></a><!----><!--]--></li><li><!--[--><a aria-current="page" href="/audition/java/basic.html#_1-14-接口和抽象类的区别是什么" class="router-link-active router-link-exact-active nav-link sidebar-item" aria-label="1.14. 接口和抽象类的区别是什么？"><!--[--><!--]--> 1.14. 接口和抽象类的区别是什么？ <!--[--><!--]--></a><!----><!--]--></li><li><!--[--><a aria-current="page" href="/audition/java/basic.html#_1-15-成员变量与局部变量的区别有哪些" class="router-link-active router-link-exact-active nav-link sidebar-item" aria-label="1.15. 成员变量与局部变量的区别有哪些？"><!--[--><!--]--> 1.15. 成员变量与局部变量的区别有哪些？ <!--[--><!--]--></a><!----><!--]--></li><li><!--[--><a aria-current="page" href="/audition/java/basic.html#_1-16-创建一个对象用什么运算符-对象实体与对象引用有何不同" class="router-link-active router-link-exact-active nav-link sidebar-item" aria-label="1.16. 创建一个对象用什么运算符？对象实体与对象引用有何不同？"><!--[--><!--]--> 1.16. 创建一个对象用什么运算符？对象实体与对象引用有何不同？ <!--[--><!--]--></a><!----><!--]--></li><li><!--[--><a aria-current="page" href="/audition/java/basic.html#_1-17-什么是方法的返回值-返回值在类的方法里的作用是什么" class="router-link-active router-link-exact-active nav-link sidebar-item" aria-label="1.17. 什么是方法的返回值？返回值在类的方法里的作用是什么？"><!--[--><!--]--> 1.17. 什么是方法的返回值？返回值在类的方法里的作用是什么？ <!--[--><!--]--></a><!----><!--]--></li><li><!--[--><a aria-current="page" href="/audition/java/basic.html#_1-18-一个类的构造方法的作用是什么-若一个类没有声明构造方法-该程序能正确执行吗-为什么" class="router-link-active router-link-exact-active nav-link sidebar-item" aria-label="1.18. 一个类的构造方法的作用是什么？若一个类没有声明构造方法，该程序能正确执行吗？为什么？"><!--[--><!--]--> 1.18. 一个类的构造方法的作用是什么？若一个类没有声明构造方法，该程序能正确执行吗？为什么？ <!--[--><!--]--></a><!----><!--]--></li><li><!--[--><a aria-current="page" href="/audition/java/basic.html#_1-19-构造方法有哪些特性" class="router-link-active router-link-exact-active nav-link sidebar-item" aria-label="1.19. 构造方法有哪些特性？"><!--[--><!--]--> 1.19. 构造方法有哪些特性？ <!--[--><!--]--></a><!----><!--]--></li><li><!--[--><a aria-current="page" href="/audition/java/basic.html#_1-20-静态方法和实例方法有何不同" class="router-link-active router-link-exact-active nav-link sidebar-item" aria-label="1.20. 静态方法和实例方法有何不同"><!--[--><!--]--> 1.20. 静态方法和实例方法有何不同 <!--[--><!--]--></a><!----><!--]--></li><li><!--[--><a aria-current="page" href="/audition/java/basic.html#_1-21-对象的相等与指向他们的引用相等-两者有什么不同" class="router-link-active router-link-exact-active nav-link sidebar-item" aria-label="1.21. 对象的相等与指向他们的引用相等，两者有什么不同？"><!--[--><!--]--> 1.21. 对象的相等与指向他们的引用相等，两者有什么不同？ <!--[--><!--]--></a><!----><!--]--></li><li><!--[--><a aria-current="page" href="/audition/java/basic.html#_1-22-在调用子类构造方法之前会先调用父类没有参数的构造方法-其目的是" class="router-link-active router-link-exact-active nav-link sidebar-item" aria-label="1.22. 在调用子类构造方法之前会先调用父类没有参数的构造方法，其目的是？"><!--[--><!--]--> 1.22. 在调用子类构造方法之前会先调用父类没有参数的构造方法，其目的是？ <!--[--><!--]--></a><!----><!--]--></li><li><!--[--><a aria-current="page" href="/audition/java/basic.html#_1-23-与-equals" class="router-link-active router-link-exact-active nav-link sidebar-item" aria-label="1.23. == 与 equals"><!--[--><!--]--> 1.23. == 与 equals <!--[--><!--]--></a><!----><!--]--></li><li><!--[--><a aria-current="page" href="/audition/java/basic.html#_1-24-hashcode-与-equals-重要" class="router-link-active router-link-exact-active nav-link sidebar-item" aria-label="1.24. hashCode 与 equals (重要)"><!--[--><!--]--> 1.24. hashCode 与 equals (重要) <!--[--><!--]--></a><ul class="sidebar-sub-items"><li><!--[--><a aria-current="page" href="/audition/java/basic.html#_1-24-1-hashcode-介绍" class="router-link-active router-link-exact-active nav-link sidebar-item" aria-label="1.24.1. hashCode() 介绍"><!--[--><!--]--> 1.24.1. hashCode() 介绍 <!--[--><!--]--></a><!----><!--]--></li><li><!--[--><a aria-current="page" href="/audition/java/basic.html#_1-24-2-为什么要有-hashcode" class="router-link-active router-link-exact-active nav-link sidebar-item" aria-label="1.24.2. 为什么要有 hashCode?"><!--[--><!--]--> 1.24.2. 为什么要有 hashCode? <!--[--><!--]--></a><!----><!--]--></li><li><!--[--><a aria-current="page" href="/audition/java/basic.html#_1-24-3-为什么重写-equals-时必须重写-hashcode-方法" class="router-link-active router-link-exact-active nav-link sidebar-item" aria-label="1.24.3. 为什么重写 equals 时必须重写 hashCode 方法？"><!--[--><!--]--> 1.24.3. 为什么重写 equals 时必须重写 hashCode 方法？ <!--[--><!--]--></a><!----><!--]--></li><li><!--[--><a aria-current="page" href="/audition/java/basic.html#_1-24-4-为什么两个对象有相同的-hashcode-值-它们也不一定是相等的" class="router-link-active router-link-exact-active nav-link sidebar-item" aria-label="1.24.4. 为什么两个对象有相同的 hashcode 值，它们也不一定是相等的？"><!--[--><!--]--> 1.24.4. 为什么两个对象有相同的 hashcode 值，它们也不一定是相等的？ <!--[--><!--]--></a><!----><!--]--></li></ul><!--]--></li><li><!--[--><a aria-current="page" href="/audition/java/basic.html#_1-25-为什么-java-中只有值传递" class="router-link-active router-link-exact-active nav-link sidebar-item" aria-label="1.25. 为什么 Java 中只有值传递？"><!--[--><!--]--> 1.25. 为什么 Java 中只有值传递？ <!--[--><!--]--></a><!----><!--]--></li><li><!--[--><a aria-current="page" href="/audition/java/basic.html#_1-26-关于-final-关键字的一些总结" class="router-link-active router-link-exact-active nav-link sidebar-item" aria-label="1.26. 关于 final 关键字的一些总结"><!--[--><!--]--> 1.26. 关于 final 关键字的一些总结 <!--[--><!--]--></a><!----><!--]--></li><li><!--[--><a aria-current="page" href="/audition/java/basic.html#_1-27-java-访问修饰符" class="router-link-active router-link-exact-active nav-link sidebar-item" aria-label="1.27. java 访问修饰符"><!--[--><!--]--> 1.27. java 访问修饰符 <!--[--><!--]--></a><!----><!--]--></li><li><!--[--><a aria-current="page" href="/audition/java/basic.html#_1-28-java-中的异常处理" class="router-link-active router-link-exact-active nav-link sidebar-item" aria-label="1.28. Java 中的异常处理"><!--[--><!--]--> 1.28. Java 中的异常处理 <!--[--><!--]--></a><ul class="sidebar-sub-items"><li><!--[--><a aria-current="page" href="/audition/java/basic.html#_1-28-1-java-异常类层次结构图" class="router-link-active router-link-exact-active nav-link sidebar-item" aria-label="1.28.1. Java 异常类层次结构图"><!--[--><!--]--> 1.28.1. Java 异常类层次结构图 <!--[--><!--]--></a><!----><!--]--></li><li><!--[--><a aria-current="page" href="/audition/java/basic.html#_1-28-2-throwable-类常用方法" class="router-link-active router-link-exact-active nav-link sidebar-item" aria-label="1.28.2. Throwable 类常用方法"><!--[--><!--]--> 1.28.2. Throwable 类常用方法 <!--[--><!--]--></a><!----><!--]--></li><li><!--[--><a aria-current="page" href="/audition/java/basic.html#_1-28-3-异常处理总结" class="router-link-active router-link-exact-active nav-link sidebar-item" aria-label="1.28.3. 异常处理总结"><!--[--><!--]--> 1.28.3. 异常处理总结 <!--[--><!--]--></a><!----><!--]--></li></ul><!--]--></li><li><!--[--><a aria-current="page" href="/audition/java/basic.html#_1-29-java-序列化中如果有些字段不想进行序列化-怎么办" class="router-link-active router-link-exact-active nav-link sidebar-item" aria-label="1.29. Java 序列化中如果有些字段不想进行序列化，怎么办？"><!--[--><!--]--> 1.29. Java 序列化中如果有些字段不想进行序列化，怎么办？ <!--[--><!--]--></a><!----><!--]--></li><li><!--[--><a aria-current="page" href="/audition/java/basic.html#_1-30-获取用键盘输入常用的两种方法" class="router-link-active router-link-exact-active nav-link sidebar-item" aria-label="1.30. 获取用键盘输入常用的两种方法"><!--[--><!--]--> 1.30. 获取用键盘输入常用的两种方法 <!--[--><!--]--></a><ul class="sidebar-sub-items"><li><!--[--><a aria-current="page" href="/audition/java/basic.html#_1-30-1-方法-1-通过-scanner" class="router-link-active router-link-exact-active nav-link sidebar-item" aria-label="1.30.1. 方法 1:通过 Scanner"><!--[--><!--]--> 1.30.1. 方法 1:通过 Scanner <!--[--><!--]--></a><!----><!--]--></li><li><!--[--><a aria-current="page" href="/audition/java/basic.html#_1-30-2-方法-2-通过-bufferedreader" class="router-link-active router-link-exact-active nav-link sidebar-item" aria-label="1.30.2. 方法 2:通过 BufferedReader"><!--[--><!--]--> 1.30.2. 方法 2:通过 BufferedReader <!--[--><!--]--></a><!----><!--]--></li></ul><!--]--></li><li><!--[--><a aria-current="page" href="/audition/java/basic.html#_1-31-java-中-io-流" class="router-link-active router-link-exact-active nav-link sidebar-item" aria-label="1.31. Java 中 IO 流"><!--[--><!--]--> 1.31. Java 中 IO 流 <!--[--><!--]--></a><ul class="sidebar-sub-items"><li><!--[--><a aria-current="page" href="/audition/java/basic.html#_1-31-1-java-中-io-流分为几种" class="router-link-active router-link-exact-active nav-link sidebar-item" aria-label="1.31.1. Java 中 IO 流分为几种？"><!--[--><!--]--> 1.31.1. Java 中 IO 流分为几种？ <!--[--><!--]--></a><!----><!--]--></li><li><!--[--><a aria-current="page" href="/audition/java/basic.html#_1-31-2-既然有了字节流-为什么还要有字符流" class="router-link-active router-link-exact-active nav-link sidebar-item" aria-label="1.31.2. 既然有了字节流，为什么还要有字符流？"><!--[--><!--]--> 1.31.2. 既然有了字节流，为什么还要有字符流？ <!--[--><!--]--></a><!----><!--]--></li><li><!--[--><a aria-current="page" href="/audition/java/basic.html#_1-31-3-bio-nio-aio-有什么区别" class="router-link-active router-link-exact-active nav-link sidebar-item" aria-label="1.31.3. BIO,NIO,AIO 有什么区别？"><!--[--><!--]--> 1.31.3. BIO,NIO,AIO 有什么区别？ <!--[--><!--]--></a><!----><!--]--></li></ul><!--]--></li><li><!--[--><a aria-current="page" href="/audition/java/basic.html#_1-32-深拷贝-vs-浅拷贝" class="router-link-active router-link-exact-active nav-link sidebar-item" aria-label="1.32. 深拷贝 vs 浅拷贝"><!--[--><!--]--> 1.32. 深拷贝 vs 浅拷贝 <!--[--><!--]--></a><!----><!--]--></li></ul><!--]--></li><li><!--[--><a href="/audition/java/collection.html" class="nav-link sidebar-item" aria-label="1. Java 集合"><!--[--><!--]--> 1. Java 集合 <!--[--><!--]--></a><!----><!--]--></li><li><!--[--><a href="/audition/java/multithreadingbasic.html" class="nav-link sidebar-item" aria-label="1. 多线程-基础"><!--[--><!--]--> 1. 多线程-基础 <!--[--><!--]--></a><!----><!--]--></li><li><!--[--><a href="/audition/java/multithreadingadvanced.html" class="nav-link sidebar-item" aria-label="1. 多线程-进阶"><!--[--><!--]--> 1. 多线程-进阶 <!--[--><!--]--></a><!----><!--]--></li><li><!--[--><a href="/audition/java/jvm.html" class="nav-link sidebar-item" aria-label="1. Java 虚拟机"><!--[--><!--]--> 1. Java 虚拟机 <!--[--><!--]--></a><!----><!--]--></li></ul><!--]--><!--]--></ul><!--[--><!--]--></aside><!--]--><!--[--><main class="page"><!--[--><!--]--><div class="theme-default-content"><!--[--><h1 id="_1-java-基础" tabindex="-1"><a class="header-anchor" href="#_1-java-基础" aria-hidden="true">#</a> 1. Java 基础</h1><h2 id="_1-1-面向对象和面向过程的区别" tabindex="-1"><a class="header-anchor" href="#_1-1-面向对象和面向过程的区别" aria-hidden="true">#</a> 1.1. 面向对象和面向过程的区别</h2><ol><li><p>面向过程</p><p>面向过程性能比面向对象高。类调用时需要实例化，开销比较大，比较消耗资源，所以当性能是最重要的考量因素的时候，比如单片机，嵌入式开发，Linux/Unix 等一般采用面向过程开发。</p></li><li><p>面向对象</p><p>面向对象易维护，易复用，易扩展。因为面向对象有封装，继承，多态性的特性，所以可以设计出低耦合的系统，使系统更加灵活，更加易于维护。</p></li></ol><h2 id="_1-2-java-语言有哪些特点" tabindex="-1"><a class="header-anchor" href="#_1-2-java-语言有哪些特点" aria-hidden="true">#</a> 1.2. Java 语言有哪些特点？</h2><ol><li>简单易学;</li><li>面向对象 (封装，继承，多态);</li><li>平台无关性 ( Java 虚拟机实现平台无关性);</li><li>可靠性;</li><li>安全性;</li><li>支持多线程</li><li>支持网络编程并且很方便</li><li>编译与解释并存;</li></ol><h2 id="_1-3-jvm" tabindex="-1"><a class="header-anchor" href="#_1-3-jvm" aria-hidden="true">#</a> 1.3. JVM</h2><p>Java 虚拟机 (JVM) 是运行 Java 字节码的虚拟机 .JVM 有针对不同操作系统的特定实现 (Windows,Linux,macOS),目的是使用相同的字节码，它们都会给出相同的结果。</p><h3 id="_1-3-1-什么是字节码-采用字节码的好处是什么" tabindex="-1"><a class="header-anchor" href="#_1-3-1-什么是字节码-采用字节码的好处是什么" aria-hidden="true">#</a> 1.3.1. 什么是字节码？采用字节码的好处是什么？</h3><p>在 Java 中，JVM 可以理解的代码就叫做字节码 (即扩展名为 .class 的文件),它不面向任何特定的处理器，只面向虚拟机。 Java 语言通过字节码的方式，在一定程度上解决了传统解释型语言执行效率低的问题，同时又保留了解释型语言可移植的特点。所以 Java 程序运行时比较高效，而且，由于字节码并不针对一种特定的机器，因此，Java 程序无须重新编译便可在多种不同操作系统的计算机上运行。</p><h2 id="_1-4-jdk-和-jre" tabindex="-1"><a class="header-anchor" href="#_1-4-jdk-和-jre" aria-hidden="true">#</a> 1.4. JDK 和 JRE</h2><p>JDK 是 Java Development Kit，它是功能齐全的 Java SDK.它拥有 JRE 所拥有的一切，还有编译器 (javac) 和工具 (如 javadoc 和 jdb).它能够创建和编译程序。</p><p>JRE 是 Java 运行时环境。它是运行已编译 Java 程序所需的所有内容的集合，包括 Java 虚拟机 (JVM),Java 类库，java 命令和其他的一些基础构件。但是，它不能用于创建新程序。</p><h2 id="_1-5-java-和-c-的区别" tabindex="-1"><a class="header-anchor" href="#_1-5-java-和-c-的区别" aria-hidden="true">#</a> 1.5. Java 和 C++ 的区别？</h2><ol><li>都是面向对象的语言，都支持封装，继承和多态</li><li>Java 不提供指针来直接访问内存，程序内存更加安全</li><li>Java 的类是单继承的，C++ 支持多重继承;虽然 Java 的类不可以多继承，但是接口可以多实现。</li><li>Java 有自动内存管理机制，不需要程序员手动释放无用内存</li></ol><h2 id="_1-6-字符型常量-char-和字符串常量-string-的区别" tabindex="-1"><a class="header-anchor" href="#_1-6-字符型常量-char-和字符串常量-string-的区别" aria-hidden="true">#</a> 1.6. 字符型常量 (char) 和字符串常量 (string) 的区别？</h2><ol><li><p>形式上：</p><p>字符常量是单引号引起的一个字符; 字符串常量是双引号引起的若干个字符</p></li><li><p>含义上：</p><p>字符常量相当于一个整型值 ( ASCII 值),可以参加表达式运算; 字符串常量代表一个地址值 (该字符串在内存中存放位置)</p></li><li><p>占内存大小</p><p>字符常量只占 2 个字节; 字符串常量占若干个字节</p></li></ol><h2 id="_1-7-构造器-constructor-是否可被-override" tabindex="-1"><a class="header-anchor" href="#_1-7-构造器-constructor-是否可被-override" aria-hidden="true">#</a> 1.7. 构造器 Constructor 是否可被 override?</h2><p>Constructor 不能被 override(重写),但是可以 overload(重载),所以你可以看到一个类中有多个构造函数的情况。</p><h2 id="_1-8-重载和重写的区别" tabindex="-1"><a class="header-anchor" href="#_1-8-重载和重写的区别" aria-hidden="true">#</a> 1.8. 重载和重写的区别</h2><h3 id="_1-8-1-重载" tabindex="-1"><a class="header-anchor" href="#_1-8-1-重载" aria-hidden="true">#</a> 1.8.1. 重载</h3><p>发生在同一个类中，方法名必须相同，参数类型不同，个数不同，顺序不同，方法返回值和访问修饰符可以不同。</p><h3 id="_1-8-2-重写" tabindex="-1"><a class="header-anchor" href="#_1-8-2-重写" aria-hidden="true">#</a> 1.8.2. 重写</h3><p>重写发生在运行期，是子类对父类的允许访问的方法的实现过程进行重新编写。</p><ol><li>返回值类型，方法名，参数列表必须相同，抛出的异常范围小于等于父类，访问修饰符范围大于等于父类。</li><li>如果父类方法访问修饰符为 private/final/static 则子类就不能重写该方法，但是被 static 修饰的方法能够被再次声明。</li><li>构造方法无法被重写</li></ol><p>综上：重写就是子类对父类方法的重新改造，外部样子不能改变，内部逻辑可以改变</p><table><thead><tr><th style="text-align:left;">区别点</th><th style="text-align:left;">重载方法</th><th style="text-align:left;">重写方法</th></tr></thead><tbody><tr><td style="text-align:left;">发生范围</td><td style="text-align:left;">同一个类</td><td style="text-align:left;">子类</td></tr><tr><td style="text-align:left;">参数列表</td><td style="text-align:left;">必须修改</td><td style="text-align:left;">一定不能修改</td></tr><tr><td style="text-align:left;">返回类型</td><td style="text-align:left;">可修改</td><td style="text-align:left;">子类方法返回值类型应比父类方法返回值类型更小或相等</td></tr><tr><td style="text-align:left;">异常</td><td style="text-align:left;">可修改</td><td style="text-align:left;">子类方法声明抛出的异常类应比父类方法声明抛出的异常类更小或相等;</td></tr><tr><td style="text-align:left;">访问修饰符</td><td style="text-align:left;">可修改</td><td style="text-align:left;">一定不能做更严格的限制 (可以降低限制)</td></tr><tr><td style="text-align:left;">发生阶段</td><td style="text-align:left;">编译期</td><td style="text-align:left;">运行期</td></tr></tbody></table><h4 id="_1-8-2-1-方法的重写要遵循两同两小一大" tabindex="-1"><a class="header-anchor" href="#_1-8-2-1-方法的重写要遵循两同两小一大" aria-hidden="true">#</a> 1.8.2.1. 方法的重写要遵循两同两小一大</h4><ul><li>两同即方法名相同，形参列表相同;</li><li>两小指的是子类方法返回值类型应比父类方法返回值类型更小或相等，子类方法声明抛出的异常类应比父类方法声明抛出的异常类更小或相等;</li><li>一大指的是子类方法的访问权限应比父类方法的访问权限更大或相等。</li></ul><p>关于重写的返回值类型：如果方法的返回类型是 void 和基本数据类型，则返回值重写时不可修改。但是如果方法的返回值是引用类型，重写时是可以返回该引用类型的子类的。</p><h2 id="_1-9-java-面向对象编程三大特性-封装-继承-多态" tabindex="-1"><a class="header-anchor" href="#_1-9-java-面向对象编程三大特性-封装-继承-多态" aria-hidden="true">#</a> 1.9. Java 面向对象编程三大特性：封装 继承 多态</h2><h3 id="_1-9-1-封装" tabindex="-1"><a class="header-anchor" href="#_1-9-1-封装" aria-hidden="true">#</a> 1.9.1. 封装</h3><p>封装把一个对象的属性私有化，同时提供一些可以被外界访问的属性的方法，如果属性不想被外界访问，我们大可不必提供方法给外界访问。但是如果一个类没有提供给外界访问的方法，那么这个类也没有什么意义了。</p><h3 id="_1-9-2-继承" tabindex="-1"><a class="header-anchor" href="#_1-9-2-继承" aria-hidden="true">#</a> 1.9.2. 继承</h3><p>继承是使用已存在的类的定义作为基础建立新类的技术，新类的定义可以增加新的数据或新的功能，也可以用父类的功能，但不能选择性地继承父类。通过使用继承我们能够非常方便地复用以前的代码。</p><ol><li>子类拥有父类对象所有的属性和方法 (包括私有属性和私有方法),但是父类中的私有属性和方法子类是无法访问，只是拥有。</li><li>子类可以拥有自己属性和方法，即子类可以对父类进行扩展。</li><li>子类可以用自己的方式实现父类的方法。</li></ol><h3 id="_1-9-3-多态" tabindex="-1"><a class="header-anchor" href="#_1-9-3-多态" aria-hidden="true">#</a> 1.9.3. 多态</h3><p>多态就是指程序中定义的引用变量所指向的具体类型和通过该引用变量发出的方法调用在编程时并不确定，而是在程序运行期间才确定，即一个引用变量到底会指向哪个类的实例对象，该引用变量发出的方法调用到底是哪个类中实现的方法，必须在由程序运行期间才能决定。</p><p>在 Java 中有两种形式可以实现多态：继承 (多个子类对同一方法的重写) 和接口 (实现接口并覆盖接口中同一方法).</p><h2 id="_1-10-string-stringbuffer-和-stringbuilder-的区别是什么-string-为什么是不可变的" tabindex="-1"><a class="header-anchor" href="#_1-10-string-stringbuffer-和-stringbuilder-的区别是什么-string-为什么是不可变的" aria-hidden="true">#</a> 1.10. String StringBuffer 和 StringBuilder 的区别是什么？String 为什么是不可变的？</h2><h3 id="_1-10-1-可变性" tabindex="-1"><a class="header-anchor" href="#_1-10-1-可变性" aria-hidden="true">#</a> 1.10.1. 可变性</h3><p>String 类中使用 final 关键字修饰字符数组来保存字符串，private final char value[],所以 String 对象是不可变的。</p><p>StringBuilder 与 StringBuffer 都继承自 AbstractStringBuilder 类，在 AbstractStringBuilder 中也是使用字符数组保存字符串 char[]value，但是没有用 final 关键字修饰，所以这两种对象都是可变的。</p><h3 id="_1-10-2-线程安全性" tabindex="-1"><a class="header-anchor" href="#_1-10-2-线程安全性" aria-hidden="true">#</a> 1.10.2. 线程安全性</h3><p>String 中的对象是不可变的，也就可以理解为常量，线程安全.AbstractStringBuilder 是 StringBuilder 与 StringBuffer 的公共父类，定义了一些字符串的基本操作，如 expandCapacity,append,insert,indexOf 等公共方法.StringBuffer 对方法加了同步锁或者对调用的方法加了同步锁，所以是线程安全的.StringBuilder 并没有对方法进行加同步锁，所以是非线程安全的。</p><h3 id="_1-10-3-性能" tabindex="-1"><a class="header-anchor" href="#_1-10-3-性能" aria-hidden="true">#</a> 1.10.3. 性能</h3><p>每次对 String 类型进行改变的时候，都会生成一个新的 String 对象，然后将指针指向新的 String 对象.StringBuffer 每次都会对 StringBuffer 对象本身进行操作，而不是生成新的对象并改变对象引用。相同情况下使用 StringBuilder 相比使用 StringBuffer 仅能获得 10%~15% 左右的性能提升，但却要冒多线程不安全的风险。</p><h3 id="_1-10-4-对于三者使用的总结" tabindex="-1"><a class="header-anchor" href="#_1-10-4-对于三者使用的总结" aria-hidden="true">#</a> 1.10.4. 对于三者使用的总结</h3><ol><li>操作少量的数据：适用 String</li><li>单线程操作字符串缓冲区下操作大量数据：适用 StringBuilder</li><li>多线程操作字符串缓冲区下操作大量数据：适用 StringBuffer</li></ol><h2 id="_1-11-自动装箱与拆箱" tabindex="-1"><a class="header-anchor" href="#_1-11-自动装箱与拆箱" aria-hidden="true">#</a> 1.11. 自动装箱与拆箱</h2><p><img src="/audition/assets/img/1640320181758.f7fb8733.png" alt="picture 5"></p><ol><li>装箱：将基本类型用它们对应的引用类型包装起来;</li><li>拆箱：将包装类型转换为基本数据类型;</li></ol><h2 id="_1-12-在一个静态方法内调用一个非静态成员为什么是非法的" tabindex="-1"><a class="header-anchor" href="#_1-12-在一个静态方法内调用一个非静态成员为什么是非法的" aria-hidden="true">#</a> 1.12. 在一个静态方法内调用一个非静态成员为什么是非法的？</h2><p>由于静态方法可以不通过对象进行调用，因此在静态方法里，不能调用其他非静态变量，也不可以访问非静态变量成员。</p><p>类的静态成员 (变量或方法) 属于类本身，在类加载的时候就会分配内存，可以通过类名直接访问</p><p>非静态成员 (变量或方法) 属于类的对象，只有在类的对象产生 (实例化) 时才会分配内存，然后通过类的对象 (实例) 去访问</p><p>所以，如果一个类的静态方法去调用非静态方法或变量的时候，因为类的静态方法存在的时候，类的非静态成员可能不存在，访问一个内存中不存在的东西当然会出错</p><h2 id="_1-13-在-java-中定义一个不做事且没有参数的构造方法的作用" tabindex="-1"><a class="header-anchor" href="#_1-13-在-java-中定义一个不做事且没有参数的构造方法的作用" aria-hidden="true">#</a> 1.13. 在 Java 中定义一个不做事且没有参数的构造方法的作用</h2><p>Java 程序在执行子类的构造方法之前，如果没有用 super() 来调用父类特定的构造方法，则会调用父类中没有参数的构造方法。因此，如果父类中只定义了有参数的构造方法，而在子类的构造方法中又没有用 super() 来调用父类中特定的构造方法，则编译时将发生错误，因为 Java 程序在父类中找不到没有参数的构造方法可供执行。解决办法是在父类里加上一个不做事且没有参数的构造方法。</p><h2 id="_1-14-接口和抽象类的区别是什么" tabindex="-1"><a class="header-anchor" href="#_1-14-接口和抽象类的区别是什么" aria-hidden="true">#</a> 1.14. 接口和抽象类的区别是什么？</h2><ol><li>接口的方法默认是 public，所有方法在接口中不能有实现 (Java 8 开始接口方法可以有默认实现),而抽象类可以有非抽象的方法。</li><li>接口中除了 static,final 变量，不能有其他变量，而抽象类中则不一定。</li><li>一个类可以实现多个接口，但只能实现一个抽象类。接口自己本身可以通过 extends 关键字扩展多个接口。</li><li>接口方法默认修饰符是 public，抽象方法可以有 public,protected 和 default 这些修饰符 (抽象方法就是为了被重写所以不能使用 private 关键字修饰！).</li><li>从设计层面来说，抽象是对类的抽象，是一种模板设计，而接口是对行为的抽象，是一种行为的规范。</li></ol><h2 id="_1-15-成员变量与局部变量的区别有哪些" tabindex="-1"><a class="header-anchor" href="#_1-15-成员变量与局部变量的区别有哪些" aria-hidden="true">#</a> 1.15. 成员变量与局部变量的区别有哪些？</h2><ol><li><p>从语法形式上看：</p><p>成员变量是属于类的，而局部变量是在方法中定义的变量或是方法的参数;成员变量可以被 public,private,static 等修饰符所修饰，而局部变量不能被访问控制修饰符及 static 所修饰;但是，成员变量和局部变量都能被 final 所修饰。</p></li><li><p>从变量在内存中的存储方式来看：</p><p>如果成员变量是使用 static 修饰的，那么这个成员变量是属于类的，如果没有使用 static 修饰，这个成员变量是属于实例的。对象存于堆内存，如果局部变量类型为基本数据类型，那么存储在栈内存，如果为引用数据类型，那存放的是指向堆内存对象的引用或者是指向常量池中的地址。</p></li><li><p>从变量在内存中的生存时间上看：</p><p>成员变量是对象的一部分，它随着对象的创建而存在，而局部变量随着方法的调用而自动消失。</p></li><li><p>成员变量如果没有被赋初值：</p><p>自动以类型的默认值而赋值，而局部变量则不会自动赋值。例外：被 final 修饰的成员变量也必须显式地赋值</p></li></ol><h2 id="_1-16-创建一个对象用什么运算符-对象实体与对象引用有何不同" tabindex="-1"><a class="header-anchor" href="#_1-16-创建一个对象用什么运算符-对象实体与对象引用有何不同" aria-hidden="true">#</a> 1.16. 创建一个对象用什么运算符？对象实体与对象引用有何不同？</h2><p>new 运算符创建对象实例，对象实例在堆内存中，对象引用存放在栈内存中，对象引用指向对象实例。一个对象引用可以指向 0 个或 1 个对象; 一个对象可以有 n 个引用指向它</p><h2 id="_1-17-什么是方法的返回值-返回值在类的方法里的作用是什么" tabindex="-1"><a class="header-anchor" href="#_1-17-什么是方法的返回值-返回值在类的方法里的作用是什么" aria-hidden="true">#</a> 1.17. 什么是方法的返回值？返回值在类的方法里的作用是什么？</h2><p>方法的返回值是指我们获取到的某个方法体中的代码执行后产生的结果！(前提是该方法可能产生结果).返回值的作用：接收出结果，使得它可以用于其他的操作！</p><h2 id="_1-18-一个类的构造方法的作用是什么-若一个类没有声明构造方法-该程序能正确执行吗-为什么" tabindex="-1"><a class="header-anchor" href="#_1-18-一个类的构造方法的作用是什么-若一个类没有声明构造方法-该程序能正确执行吗-为什么" aria-hidden="true">#</a> 1.18. 一个类的构造方法的作用是什么？若一个类没有声明构造方法，该程序能正确执行吗？为什么？</h2><p>主要作用是完成对类对象的初始化工作，可以执行。因为一个类即使没有声明构造方法也会有默认的不带参数的构造方法。</p><h2 id="_1-19-构造方法有哪些特性" tabindex="-1"><a class="header-anchor" href="#_1-19-构造方法有哪些特性" aria-hidden="true">#</a> 1.19. 构造方法有哪些特性？</h2><ol><li>名字与类名相同。</li><li>没有返回值，但不能用 void 声明构造函数。</li><li>生成类的对象时自动执行，无需调用。</li></ol><h2 id="_1-20-静态方法和实例方法有何不同" tabindex="-1"><a class="header-anchor" href="#_1-20-静态方法和实例方法有何不同" aria-hidden="true">#</a> 1.20. 静态方法和实例方法有何不同</h2><ol><li><p>在外部调用静态方法时，可以使用&quot;类名。方法名&quot;的方式，也可以使用&quot;对象名。方法名&quot;的方式。而实例方法只有后面这种方式。也就是说，调用静态方法可以无需创建对象。</p></li><li><p>静态方法在访问本类的成员时，只允许访问静态成员 (即静态成员变量和静态方法),而不允许访问实例成员变量和实例方法;实例方法则无此限制。</p></li></ol><h2 id="_1-21-对象的相等与指向他们的引用相等-两者有什么不同" tabindex="-1"><a class="header-anchor" href="#_1-21-对象的相等与指向他们的引用相等-两者有什么不同" aria-hidden="true">#</a> 1.21. 对象的相等与指向他们的引用相等，两者有什么不同？</h2><ol><li>对象的相等，比较的是内存中存放的内容是否相等。</li><li>引用相等，比较的是他们指向的内存地址是否相等。</li></ol><h2 id="_1-22-在调用子类构造方法之前会先调用父类没有参数的构造方法-其目的是" tabindex="-1"><a class="header-anchor" href="#_1-22-在调用子类构造方法之前会先调用父类没有参数的构造方法-其目的是" aria-hidden="true">#</a> 1.22. 在调用子类构造方法之前会先调用父类没有参数的构造方法，其目的是？</h2><p>帮助子类做初始化工作。</p><h2 id="_1-23-与-equals" tabindex="-1"><a class="header-anchor" href="#_1-23-与-equals" aria-hidden="true">#</a> 1.23. == 与 equals</h2><ol><li><p>== : 它的作用是判断两个对象的地址是不是相等。即，判断两个对象是不是同一个对象 基本数据类型<code>==</code>比较的是值，引用数据类型==比较的是内存地址。</p></li><li><p>equals() : 它的作用也是判断两个对象是否相等。但它一般有两种使用情况：</p></li></ol><ul><li>情况 1:类没有覆盖 equals() 方法。则通过 equals() 比较该类的两个对象时，等价于通过==比较这两个对象。</li><li>情况 2:类覆盖了 equals() 方法。一般，我们都覆盖 equals() 方法来比较两个对象的内容是否相等;若它们的内容相等，则返回 true (即，认为这两个对象相等).</li><li>String 中的 equals 方法是被重写过的，因为 object 的 equals 方法是比较的对象的内存地址，而 String 的 equals 方法比较的是对象的值。</li><li>当创建 String 类型的对象时，虚拟机会在常量池中查找有没有已经存在的值和要创建的值相同的对象，如果有就把它赋给当前引用。如果没有就在常量池中重新创建一个 String 对象。</li></ul><h2 id="_1-24-hashcode-与-equals-重要" tabindex="-1"><a class="header-anchor" href="#_1-24-hashcode-与-equals-重要" aria-hidden="true">#</a> 1.24. hashCode 与 equals (重要)</h2><h3 id="_1-24-1-hashcode-介绍" tabindex="-1"><a class="header-anchor" href="#_1-24-1-hashcode-介绍" aria-hidden="true">#</a> 1.24.1. hashCode() 介绍</h3><p>hashCode() 的作用是获取哈希码，也称为散列码;它实际上是返回一个 int 整数。这个哈希码的作用是确定该对象在哈希表中的索引位置.hashCode() 定义在 JDK 的 Object 类中，这就意味着 Java 中的任何类都包含有 hashCode() 函数。另外需要注意的是: Object 的 hashcode 方法是本地方法，也就是用 c 语言或 c++ 实现的，该方法通常用来将对象的内存地址转换为整数之后返回。</p><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">native</span> <span class="token keyword">int</span> <span class="token function">hashCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div><p>散列表存储的是键值对 (key-value), 它的特点是：能根据键快速的检索出对应的值。</p><h3 id="_1-24-2-为什么要有-hashcode" tabindex="-1"><a class="header-anchor" href="#_1-24-2-为什么要有-hashcode" aria-hidden="true">#</a> 1.24.2. 为什么要有 hashCode?</h3><p>我们以 HashSet 如何检查重复为例子来说明为什么要有 hashCode?</p><p>当你把对象加入 HashSet 时，HashSet 会先计算对象的 hashcode 值来判断对象加入的位置，同时也会与其他已经加入的对象的 hashcode 值作比较，如果没有相符的 hashcode,HashSet 会假设对象没有重复出现。但是如果发现有相同 hashcode 值的对象，这时会调用 equals() 方法来检查 hashcode 相等的对象是否真的相同。如果两者相同，HashSet 就不会让其加入操作成功。如果不同的话，就会重新散列到其他位置。这样就大大减少了 equals 的次数，相应就大大提高了执行速度。</p><h3 id="_1-24-3-为什么重写-equals-时必须重写-hashcode-方法" tabindex="-1"><a class="header-anchor" href="#_1-24-3-为什么重写-equals-时必须重写-hashcode-方法" aria-hidden="true">#</a> 1.24.3. 为什么重写 equals 时必须重写 hashCode 方法？</h3><p>如果两个对象相等，则 hashcode 一定也是相同的。两个对象相等，对两个对象分别调用 equals 方法都返回 true.但是，两个对象有相同的 hashcode 值，它们也不一定是相等的 .因此，equals 方法被覆盖过，则 hashCode 方法也必须被覆盖。</p><h3 id="_1-24-4-为什么两个对象有相同的-hashcode-值-它们也不一定是相等的" tabindex="-1"><a class="header-anchor" href="#_1-24-4-为什么两个对象有相同的-hashcode-值-它们也不一定是相等的" aria-hidden="true">#</a> 1.24.4. 为什么两个对象有相同的 hashcode 值，它们也不一定是相等的？</h3><p>因为 hashCode() 所使用的杂凑算法也许刚好会让多个对象传回相同的杂凑值。越糟糕的杂凑算法越容易碰撞，但这也与数据值域分布的特性有关，所谓碰撞也就是指的是不同的对象得到相同的 hashCode. 比如 HashSet，如果 HashSet 在对比的时候，同样的 hashcode 有多个对象，它会使用 equals() 来判断是否真的相同。也就是说 hashcode 只是用来缩小查找成本。</p><h2 id="_1-25-为什么-java-中只有值传递" tabindex="-1"><a class="header-anchor" href="#_1-25-为什么-java-中只有值传递" aria-hidden="true">#</a> 1.25. 为什么 Java 中只有值传递？</h2><p>按值调用 (call by value) 表示方法接收的是调用者提供的值，而按引用调用 (call by reference) 表示方法接收的是调用者提供的变量地址。一个方法可以修改传递引用所对应的变量值，而不能修改传递值调用所对应的变量值。它用来描述各种程序设计语言 (不只是 Java) 中方法参数传递方式。</p><p>Java 程序设计语言总是采用按值调用。也就是说，方法得到的是所有参数值的一个拷贝，也就是说，方法不能修改传递给它的任何参数变量的内容。</p><h2 id="_1-26-关于-final-关键字的一些总结" tabindex="-1"><a class="header-anchor" href="#_1-26-关于-final-关键字的一些总结" aria-hidden="true">#</a> 1.26. 关于 final 关键字的一些总结</h2><p>final 关键字主要用在三个地方：变量，方法，类。</p><ol><li>对于一个 final 变量，如果是基本数据类型的变量，则其数值一旦在初始化之后便不能更改;如果是引用类型的变量，则在对其初始化之后便不能再让其指向另一个对象。</li><li>当用 final 修饰一个类时，表明这个类不能被继承.final 类中的所有成员方法都会被隐式地指定为 final 方法。</li><li>使用 final 方法的原因有两个。第一个原因是把方法锁定，以防任何继承类修改它的含义;第二个原因是效率，final 方法比非 final 方法要快，因为在编译的时候已经静态绑定了，不需要在运行时再动态绑定。类的 private 方法会隐式地被指定为 final 方法</li></ol><h2 id="_1-27-java-访问修饰符" tabindex="-1"><a class="header-anchor" href="#_1-27-java-访问修饰符" aria-hidden="true">#</a> 1.27. java 访问修饰符</h2><ol><li>public: 可以被所有其他类所访问。</li><li>protected: 自身，子类及同一个包中类可以访问。</li><li>default( 默认) : 同一包中的类可以访问，声明时没有加修饰符，认为是 friendly.</li><li>private: 只能被自身类访问和修改。</li></ol><table><thead><tr><th>修饰符</th><th>类</th><th>包</th><th>子类</th><th>其他包</th></tr></thead><tbody><tr><td>public</td><td>Y</td><td>Y</td><td>Y</td><td>Y</td></tr><tr><td>protected</td><td>Y</td><td>Y</td><td>Y</td><td>N</td></tr><tr><td>default</td><td>Y</td><td>Y</td><td>N</td><td>N</td></tr><tr><td>private</td><td>Y</td><td>N</td><td>N</td><td>N</td></tr></tbody></table><p>Java 中，可以使用访问控制符来保护对类，变量，方法和构造方法的访问</p><h2 id="_1-28-java-中的异常处理" tabindex="-1"><a class="header-anchor" href="#_1-28-java-中的异常处理" aria-hidden="true">#</a> 1.28. Java 中的异常处理</h2><p><img src="/audition/assets/img/1640343884805.075416b8.png" alt="picture 1"><br><img src="/audition/assets/img/1640343893506.7cfa7397.png" alt="picture 2"></p><h3 id="_1-28-1-java-异常类层次结构图" tabindex="-1"><a class="header-anchor" href="#_1-28-1-java-异常类层次结构图" aria-hidden="true">#</a> 1.28.1. Java 异常类层次结构图</h3><p>在 Java 中，所有的异常都有一个共同的祖先 java.lang 包中的 Throwable 类.Throwable 类有两个重要的子类 Exception(异常) 和 Error(错误).Exception 能被程序本身处理 (try-catch), Error 是无法处理的 (只能尽量避免).</p><p>Exception 和 Error 二者都是 Java 异常处理的重要子类，各自都包含大量子类。</p><ul><li>Exception :程序本身可以处理的异常，可以通过 catch 来进行捕获.Exception 又可以分为 受检查异常 (必须处理) 和 不受检查异常 (可以不处理).</li><li>Error :Error 属于程序无法处理的错误 ,我们没办法通过 catch 来进行捕获 .例如，Java 虚拟机运行错误 (Virtual MachineError),虚拟机内存不够错误 (OutOfMemoryError),类定义错误 (NoClassDefFoundError) 等 .这些异常发生时，Java 虚拟机 (JVM) 一般会选择线程终止。</li></ul><h4 id="_1-28-1-1-受检查异常" tabindex="-1"><a class="header-anchor" href="#_1-28-1-1-受检查异常" aria-hidden="true">#</a> 1.28.1.1. 受检查异常</h4><p>Java 代码在编译过程中，如果受检查异常没有被 catch/throw 处理的话，就没办法通过编译 .比如下面这段 IO 操作的代码。</p><p>除了 RuntimeException 及其子类以外，其他的 Exception 类及其子类都属于检查异常 .常见的受检查异常有: IO 相关的异常，ClassNotFoundException ,SQLException....</p><h4 id="_1-28-1-2-不受检查异常" tabindex="-1"><a class="header-anchor" href="#_1-28-1-2-不受检查异常" aria-hidden="true">#</a> 1.28.1.2. 不受检查异常</h4><p>Java 代码在编译过程中 ,我们即使不处理不受检查异常也可以正常通过编译。</p><p>RuntimeException 及其子类都统称为非受检查异常，例如:NullPoin​terException,NumberFormatException(字符串转换为数字),ArrayIndexOutOfBoundsException(数组越界),ClassCastException(类型转换错误),ArithmeticException(算术错误) 等。</p><h3 id="_1-28-2-throwable-类常用方法" tabindex="-1"><a class="header-anchor" href="#_1-28-2-throwable-类常用方法" aria-hidden="true">#</a> 1.28.2. Throwable 类常用方法</h3><ul><li>public string getMessage():返回异常发生时的简要描述</li><li>public string toString():返回异常发生时的详细信息</li><li>public string getLocalizedMessage():返回异常对象的本地化信息。使用 Throwable 的子类覆盖这个方法，可以生成本地化信息。如果子类没有覆盖该方法，则该方法返回的信息与 getMessage() 返回的结果相同</li><li>public void printStackTrace():在控制台上打印 Throwable 对象封装的异常信息</li></ul><h3 id="_1-28-3-异常处理总结" tabindex="-1"><a class="header-anchor" href="#_1-28-3-异常处理总结" aria-hidden="true">#</a> 1.28.3. 异常处理总结</h3><ul><li>try 块：用于捕获异常。其后可接零个或多个 catch 块，如果没有 catch 块，则必须跟一个 finally 块。</li><li>catch 块：用于处理 try 捕获到的异常。</li><li>finally 块：无论是否捕获或处理异常，finally 块里的语句都会被执行。当在 try 块或 catch 块中遇到 return 语句时，finally 语句块将在方法返回之前被执行。</li></ul><h4 id="_1-28-3-1-在以下-3-种特殊情况下-finally-块不会被执行" tabindex="-1"><a class="header-anchor" href="#_1-28-3-1-在以下-3-种特殊情况下-finally-块不会被执行" aria-hidden="true">#</a> 1.28.3.1. 在以下 3 种特殊情况下，finally 块不会被执行</h4><ol><li>在 try 或 finally 块中用了 System.exit(int) 退出程序。但是，如果 System.exit(int) 在异常语句之后，finally 还是会被执行</li><li>程序所在的线程死亡。</li><li>关闭 CPU.</li></ol><h2 id="_1-29-java-序列化中如果有些字段不想进行序列化-怎么办" tabindex="-1"><a class="header-anchor" href="#_1-29-java-序列化中如果有些字段不想进行序列化-怎么办" aria-hidden="true">#</a> 1.29. Java 序列化中如果有些字段不想进行序列化，怎么办？</h2><p>对于不想进行序列化的变量，使用 transient 关键字修饰。</p><p>transient 关键字的作用是：阻止实例中那些用此关键字修饰的的变量序列化;当对象被反序列化时，被 transient 修饰的变量值不会被持久化和恢复.transient 只能修饰变量，不能修饰类和方法。</p><h2 id="_1-30-获取用键盘输入常用的两种方法" tabindex="-1"><a class="header-anchor" href="#_1-30-获取用键盘输入常用的两种方法" aria-hidden="true">#</a> 1.30. 获取用键盘输入常用的两种方法</h2><h3 id="_1-30-1-方法-1-通过-scanner" tabindex="-1"><a class="header-anchor" href="#_1-30-1-方法-1-通过-scanner" aria-hidden="true">#</a> 1.30.1. 方法 1:通过 Scanner</h3><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token class-name">Scanner</span> input <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Scanner</span><span class="token punctuation">(</span><span class="token class-name">System</span><span class="token punctuation">.</span>in<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">String</span> s <span class="token operator">=</span> input<span class="token punctuation">.</span><span class="token function">nextLine</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
input<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><h3 id="_1-30-2-方法-2-通过-bufferedreader" tabindex="-1"><a class="header-anchor" href="#_1-30-2-方法-2-通过-bufferedreader" aria-hidden="true">#</a> 1.30.2. 方法 2:通过 BufferedReader</h3><div class="language-java ext-java line-numbers-mode"><pre class="language-java"><code><span class="token class-name">BufferedReader</span> input <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">BufferedReader</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">InputStreamReader</span><span class="token punctuation">(</span><span class="token class-name">System</span><span class="token punctuation">.</span>in<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">String</span> s <span class="token operator">=</span> input<span class="token punctuation">.</span><span class="token function">readLine</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><h2 id="_1-31-java-中-io-流" tabindex="-1"><a class="header-anchor" href="#_1-31-java-中-io-流" aria-hidden="true">#</a> 1.31. Java 中 IO 流</h2><h3 id="_1-31-1-java-中-io-流分为几种" tabindex="-1"><a class="header-anchor" href="#_1-31-1-java-中-io-流分为几种" aria-hidden="true">#</a> 1.31.1. Java 中 IO 流分为几种？</h3><ul><li>按照流的流向分，可以分为输入流和输出流;</li><li>按照操作单元划分，可以划分为字节流和字符流;</li><li>按照流的角色划分为节点流和处理流。</li></ul><p>Java I0 流的 40 多个类都是从如下 4 个抽象类基类中派生出来的。</p><ul><li>InputStream/Reader: 所有的输入流的基类，前者是字节输入流，后者是字符输入流。</li><li>OutputStream/Writer: 所有输出流的基类，前者是字节输出流，后者是字符输出流。</li></ul><ol><li><p>按操作方式分类结构图： <img src="/audition/assets/img/1640344046679.e9a2e9a3.png" alt="picture 3"></p></li><li><p>按操作对象分类结构图：</p></li></ol><p><img src="/audition/assets/img/1640344068818.20e746d9.png" alt="picture 4"></p><h3 id="_1-31-2-既然有了字节流-为什么还要有字符流" tabindex="-1"><a class="header-anchor" href="#_1-31-2-既然有了字节流-为什么还要有字符流" aria-hidden="true">#</a> 1.31.2. 既然有了字节流，为什么还要有字符流？</h3><p>不管是文件读写还是网络发送接收，信息的最小存储单元都是字节，那为什么 I/O 流操作要分为字节流操作和字符流操作呢？</p><p>字符流是由 Java 虚拟机将字节转换得到的，问题就出在这个过程还算是非常耗时，并且，如果我们不知道编码类型就很容易出现乱码问题。所以，I/O 流就干脆提供了一个直接操作字符的接口，方便我们平时对字符进行流操作。如果音频文件，图片等媒体文件用字节流比较好，如果涉及到字符的话使用字符流比较好。</p><h3 id="_1-31-3-bio-nio-aio-有什么区别" tabindex="-1"><a class="header-anchor" href="#_1-31-3-bio-nio-aio-有什么区别" aria-hidden="true">#</a> 1.31.3. BIO,NIO,AIO 有什么区别？</h3><ol><li>BIO (Blocking I/O): 同步阻塞 I/O 模式，数据的读取写入必须阻塞在一个线程内等待其完成。在活动连接数不是特别高 (小于单机 1000) 的情况下，这种模型是比较不错的，可以让每一个连接专注于自己的 I/O 并且编程模型简单，也不用过多考虑系统的过载，限流等问题。线程池本身就是一个天然的漏斗，可以缓冲一些系统处理不了的连接或请求。但是，当面对十万甚至百万级连接的时候，传统的 BIO 模型是无能为力的。因此，我们需要一种更高效的 I/O 处理模型来应对更高的并发量。</li><li>NIO (Non-blocking/New I/O): NIO 是一种同步非阻塞的 I/O 模型，在 Java 1.4 中引入了 NIO 框架，对应 java.nio 包，提供了 Channel , Selector,Buffer 等抽象.NIO 中的 N 可以理解为 Non-blocking，不单纯是 New.它支持面向缓冲的，基于通道的 I/O 操作方法. NIO 提供了与传统 BIO 模型中的 Socket 和 ServerSocket 相对应的 SocketChannel 和 ServerSocketChannel 两种不同的套接字通道实现，两种通道都支持阻塞和非阻塞两种模式。阻塞模式使用就像传统中的支持一样，比较简单，但是性能和可靠性都不好;非阻塞模式正好与之相反。对于低负载，低并发的应用程序，可以使用同步阻塞 I/O 来提升开发速率和更好的维护性;对于高负载，高并发的 (网络) 应用，应使用 NIO 的非阻塞模式来开发</li><li>AIO (Asynchronous I/O): AIO 也就是 NIO 2.在 Java 7 中引入了 NIO 的改进版 NIO 2，它是异步非阻塞的 IO 模型。异步 IO 是基于事件和回调机制实现的，也就是应用操作之后会直接返回，不会堵塞在那里，当后台处理完成，操作系统会通知相应的线程进行后续的操作.AIO 是异步 IO 的缩写，虽然 NIO 在网络操作中，提供了非阻塞的方法，但是 NIO 的 IO 行为还是同步的。对于 NIO 来说，我们的业务线程是在 IO 操作准备好时，得到通知，接着就由这个线程自行进行 IO 操作，IO 操作本身是同步的。</li></ol><h2 id="_1-32-深拷贝-vs-浅拷贝" tabindex="-1"><a class="header-anchor" href="#_1-32-深拷贝-vs-浅拷贝" aria-hidden="true">#</a> 1.32. 深拷贝 vs 浅拷贝</h2><p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-7/java-deep-and-shallow-copy.jpg" alt="deep and shallow copy"></p><ol><li>浅拷贝：对基本数据类型进行值传递，对引用数据类型进行引用传递般的拷贝，此为浅拷贝。</li><li>深拷贝：对基本数据类型进行值传递，对引用数据类型，创建一个新的对象，并复制其内容，此为深拷贝。</li></ol><!--]--></div><footer class="page-meta"><!----><div class="meta-item last-updated"><span class="meta-item-label">Last Updated: </span><span class="meta-item-info">12/31/2021, 7:52:18 PM</span></div><div class="meta-item contributors"><span class="meta-item-label">Contributors: </span><span class="meta-item-info"><!--[--><!--[--><span class="contributor" title="email: shorestraydog@protonmail.com">shorestraydog</span><!--[-->, <!--]--><!--]--><!--[--><span class="contributor" title="email: kurotsuchi33@gmail.com">kuro-tsuchi</span><!----><!--]--><!--]--></span></div></footer><nav class="page-nav"><p class="inner"><!----><span class="next"><a href="/audition/java/collection.html" class="nav-link" aria-label="1. Java 集合"><!--[--><!--]--> 1. Java 集合 <!--[--><!--]--></a> → </span></p></nav><!--[--><!--]--></main><!--]--></div><!----><!--]--></div>
    <script src="/audition/assets/js/runtime~app.97b28792.js" defer></script><script src="/audition/assets/js/812.cf73d600.js" defer></script><script src="/audition/assets/js/app.fa25ad15.js" defer></script>
  </body>
</html>
