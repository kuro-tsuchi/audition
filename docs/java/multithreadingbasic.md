<!-----
sidebar: false
----->

# 1. 多线程-基础

## 1.1. 什么是线程和进程?

### 1.1.1. 何为进程?

进程是程序的一次执行过程, 是系统运行程序的基本单位, 因此进程是动态的. 系统运行一个程序即是一个进程从创建, 运行到消亡的过程.

在 Java 中, 当我们启动 main 函数时其实就是启动了一个 JVM 的进程, 而 main 函数所在的线程就是这个进程中的一个线程, 也称主线程.

### 1.1.2. 何为线程?

一个进程在其执行的过程中可以产生多个线程. 与进程不同的是同类的多个线程共享进程的堆和方法区资源, 但每个线程有自己的程序计数器, 虚拟机栈和本地方法栈, 所以系统在产生一个线程, 或是在各个线程之间作切换工作时, 负担要比进程小得多, 也正因为如此, 线程也被称为轻量级进程.

Java 程序天生就是多线程程序, 一个 Java 程序的运行是 main 线程和多个其他线程同时运行.

## 1.2. 请简要描述线程与进程的关系, 区别及优缺点?

### 1.2.1. 图解进程和线程的关系

![](https://javaguide.cn/assets/img/Java%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E5%9F%9FJDK1.8.37016205.png)

一个进程中可以有多个线程, 多个线程共享进程的堆和方法区(JDK 之后的元空间)资源, 但是每个线程有自己的程序计数器, 虚拟机栈和本地方法栈.

总结: 线程是进程划分成的更小的运行单位. 线程和进程最大的不同在于基本上各进程是独立的, 而各线程则不一定, 因为同一进程中的线程极有可能会相互影响. 线程执行开销小, 但不利于资源的管理和保护;而进程正相反

### 1.2.2. 程序计数器为什么是私有的?

程序计数器主要有下面两个作用:

字节码解释器通过改变程序计数器来依次读取指令, 从而实现代码的流程控制, 如: 顺序执行, 选择, 循环, 异常处理. 在多线程的情况下, 程序计数器用于记录当前线程执行的位置, 从而当线程被切换回来的时候能够知道该线程上次运行到哪儿了.

需要注意的是, 如果执行的是 native 方法, 那么程序计数器记录的是 undefined 地址, 只有执行的是 Java 代码时程序计数器记录的才是下一条指令的地址.

所以, 程序计数器私有主要是为了线程切换后能恢复到正确的执行位置.

### 1.2.3. 虚拟机栈和本地方法栈为什么是私有的?

1. 虚拟机栈: 每个 Java 方法在执行的同时会创建一个栈帧用于存储局部变量表, 操作数栈, 常量池引用等信息. 从方法调用直至执行完成的过程, 就对应着一个栈帧在 Java 虚拟机栈中入栈和出栈的过程.
1. 本地方法栈: 和虚拟机栈所发挥的作用非常相似, 区别是: 虚拟机栈为虚拟机执行 Java 方法(也就是字节码)服务, 而本地方法栈则为虚拟机使用到的 Native 方法服务. 在 HotSpot 虚拟机中和 Java 虚拟机栈合二为一.

所以, 为了保证线程中的局部变量不被别的线程访问到, 虚拟机栈和本地方法栈是线程私有的.

### 1.2.4. 一句话简单了解堆和方法区

堆和方法区是所有线程共享的资源, 其中堆是进程中最大的一块内存, 主要用于存放新创建的对象(所有对象都在这里分配内存), 方法区主要用于存放已被加载的类信息, 常量, 静态变量, 即时编译器编译后的代码等数据.

## 1.3. 说说并发与并行的区别?

1. 并发: 同一时间段, 多个任务都在执行(单位时间内不一定同时执行);
1. 并行: 单位时间内, 多个任务同时执行.

## 1.4. 为什么要使用多线程呢?

1. 从计算机底层来说: 线程可以比作是轻量级的进程, 是程序执行的最小单位,线程间的切换和调度的成本远远小于进程. 另外, 多核 CPU 时代意味着多个线程可以同时运行, 这减少了线程上下文切换的开销.
1. 从当代互联网发展趋势来说: 现在的系统动不动就要求百万级甚至千万级的并发量, 而多线程并发编程正是高并发的的基础, 利用好多线程机制可以大大提高系统整体的并发能力以及性能.

## 1.5. 使用多线程可能带来什么问题?

并发编程的目的就是为了能提高程序的执行效率, 提高程序运行速度, 但是并发编程并不总是能提高程序运行速度的, 而且并发编程可能会遇到很多问题, 比如: 内存泄漏, 上下文切换, 死锁.

## 1.6. 说说线程的生命周期和状态?

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3493f9a6c6464113a82f3f0a9eb90618~tplv-k3u1fbpfcp-watermark.awebp)

六种状态, 分别是新建( New) , 就绪/运行( Runnable) , 结束( Terminated) , 阻塞状态( Blocked) , 等待( Waiting) , 超时等待( Time_Waiting) .

线程创建之后它将处于 NEW(新建)状态, 调用 start()方法后开始运行, 线程这时候处于 READY(可运行)状态. 可运行状态的线程获得了 CPU 时间片(timeslice)后就处于 RUNNING(运行)状态.
当线程执行 wait()方法之后, 线程进入 WAITING(等待)状态. 进入等待状态的线程需要依靠其他线程的通知才能够返回到运行状态, 而 TIME_WAITING(超时等待)状态相当于在等待状态的基础上增加了超时限制, 比如通过 sleep(longmillis)方法或 wait(longmillis)方法可以将 Java 线程置于 TIMEDWAITING 状态. 当超时时间到达后 Java 线程将会返回到 RUNNABLE 状态. 当线程调用同步方法时, 在没有获取到锁的情况下, 线程将会进入到 BLOCKED(阻塞)状态. 线程在执行 Runnable 的 run()方法之后将会进入到 TERMINATED(终止)状态.

## 1.7. 什么是上下文切换?

多线程编程中一般线程的个数都大于 CPU 核心的个数, 而一个 CPU 核心在任意时刻只能被一个线程使用, 为了让这些线程都能得到有效执行, CPU 采取的策略是为每个线程分配时间片并轮转的形式. 当一个线程的时间片用完的时候就会重新处于就绪状态让给其他线程使用, 这个过程就属于一次上下文切换.

概括来说就是: 当前任务在执行完 CPU 时间片切换到另一个任务之前会先保存自己的状态, 以便下次再切换回这个任务时, 可以再加载这个任务的状态. 任务从保存到再加载的过程就是一次上下文切换.

## 1.8. 什么是线程死锁?如何避免死锁?

### 1.8.1. 认识线程死锁

线程死锁描述的是这样一种情况: 多个线程同时被阻塞, 它们中的一个或者全部都在等待某个资源被释放. 由于线程被无限期地阻塞, 因此程序不可能正常终止.

如下图所示, 线程 A 持有资源 线程 B 持有资源 他们同时都想申请对方的资源, 所以这两个线程就会互相等待而进入死锁状态.

![](https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-4/2019-4%E6%AD%BB%E9%94%811.png)

#### 1.8.1.1. 产生死锁必须具备以下四个条件

1. 互斥条件: 该资源任意一个时刻只由一个线程占用.
1. 请求与保持条件: 一个进程因请求资源而阻塞时, 对已获得的资源保持不放.
1. 不剥夺条件: 线程已获得的资源在末使用完之前不能被其他线程强行剥夺, 只有自己使用完毕后才释放资源.
1. 循环等待条件: 若干进程之间形成一种头尾相接的循环等待资源关系.

## 1.9. 如何避免线程死锁?

为了避免死锁, 只要破坏产生死锁的四个条件中的其中一个就可以

1. 破坏互斥条件 : 这个条件我们没有办法破坏, 因为我们用锁本来就是想让他们互斥的
1. 破坏请求与保持条件 : 一次性申请所有的资源.
1. 破坏不剥夺条件 : 占用部分资源的线程进一步申请其他资源时, 如果申请不到, 可以主动释放它占有的资源.
1. 破坏循环等待条件 : 靠按序申请资源来预防. 按某一顺序申请资源, 释放资源则反序释放. 破坏循环等待条件.

## 1.10. 说说 sleep()方法和 wait()方法区别和共同点?

### 1.10.1. 区别

sleep() 方法没有释放锁, 而 wait() 方法释放了锁 .

### 1.10.2. 共同点

两者都可以暂停线程的执行.

1. wait() 通常被用于线程间交互/通信, sleep()通常被用于暂停执行.
1. wait() 方法被调用后, 线程不会自动苏醒, 需要别的线程调用同一个对象上的 notify()或者 notifyAll() 方法. sleep()方法执行完成后, 线程会自动苏醒. 或者可以使用 wait(long timeout) 超时后线程会自动苏醒.

```java
public class MultiThread {
    public static void main(String[] args) {
        new Thread(new Thread1()).start();

        try {
            Thread.sleep(10);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }

        new Thread(new Thread2()).start();
    }

    private static class Thread1 implements Runnable {
        @Override
        public void run() {
            //由于 Thread1和下面Thread2内部run方法要用同一对象作为监视器，如果用this则Thread1和Threa2的this不是同一对象
            //所以用MultiThread.class这个字节码对象，当前虚拟机里引用这个变量时指向的都是同一个对象
            synchronized (MultiThread.class) {
                System.out.println("enter thread1 ...");
                System.out.println("thread1 is waiting");

                try {
                    //释放锁有两种方式：(1)程序自然离开监视器的范围，即离开synchronized关键字管辖的代码范围
                    //(2)在synchronized关键字管辖的代码内部调用监视器对象的wait()方法。这里使用wait方法
                    MultiThread.class.wait();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }

                System.out.println("thread1 is going on ...");
                System.out.println("thread1 is being over!");
            }
        }
    }

    private static class Thread2 implements Runnable {
        @Override
        public void run() {
            //notify方法并不释放锁，即使thread2调用了下面的sleep方法休息10ms，但thread1仍然不会执行
            //因为thread2没有释放锁，所以Thread1得不到锁而无法执行
            synchronized (MultiThread.class) {
                System.out.println("enter thread2 ...");
                System.out.println(
                    "thread2 notify other thread can release wait status ...");
                MultiThread.class.notify();
                System.out.println("thread2 is sleeping ten millisecond ...");

                try {
                    Thread.sleep(10);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }

                System.out.println("thread2 is going on ...");
                System.out.println("thread2 is being over!");
            }
        }
    }
}

```

## 1.11. 为什么我们调用 start()方法时会执行 run()方法, 为什么我们不能直接调用 run()方法?

调用 start()方法方可启动线程并使线程进入就绪状态, 直接执行 run()方法的话不会以多线程的方式执行.

new 一个 Thread, 线程进入了新建状态. 调用 start()方法, 会启动一个线程并使线程进入了就绪状态, 当分配到时间片后就可以开始运行了. start()会执行线程的相应准备工作, 然后自动执行 run()方法的内容, 这是真正的多线程工作. 但是, 直接执行 run()方法, 会把 run()方法当成一个 main 线程下的普通方法去执行, 并不会在某个线程中执行它, 所以这并不是多线程工作.
