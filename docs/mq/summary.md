<!-- ---
sidebar: false
--- -->

# 1. summary

## 1.1. 为什么要用消息队列

![20220406181848](https://raw.githubusercontent.com/kuro-tsuchi/my-picgo/master/md/img/20220406181848.png)

消息队列是一个存放消息的容器. 使用消息队列主要是为了通过异步处理提高系统性能和削峰,降低系统耦合性.

队列 Queue 是一种先进先出的数据结构,所以消费消息时也是按照顺序来消费.

### 1.1.1. 异步

通过异步处理可以提高系统性能,减少响应时间, 将用户的请求数据存储到消息队列之后就立即返回结果. 随后,系统再对消息队列中的消息进行消费.

e.g. 用户的充值数据写入消息队列, 充值业务处理完后, 异步发送邮件或短信或站内信通知用户成功

### 1.1.2. 解耦

![picture 2](../.vuepress/public/assets/images/1640734855701.png)

生产者和消费者之间没有直接耦合,生产者将消息发送至分布式消息队列即结束对消息的处理,消费者从分布式消息队列获取该消息后进行后续处理.

#### 1.1.2.1. 作用

服务之间进行解耦,可以减少服务之间的影响,提高系统的稳定性和可扩展性.
另外,解耦之后可以实现数据分发.生产者发送一个消息后,可以由多个消费者来处理.

### 1.1.3. 削峰(限流)

将短时间高并发产生的事务消息存储在消息队列中, 后端服务再慢慢去消费这些消息, 避免高并发把后端服务打垮.

> 在电子商务一些秒杀,促销活动中,合理使用消息队列可以有效抵御促销活动刚开始大量订单涌入对系统的冲击.

### 1.1.4. 使用消息队列带来的一些问题

1. 系统可用性降低:需要去考虑消息丢失或者说消息队列宕机, 整个业务都会受到影响
1. 系统复杂性提高:需要考虑重复消费,消息丢失的情况,保证消息的顺序等问题
1. 系统一致性问题:消息的多个消费者如果没有正确消费消息就会导致数据不一致的情况

## 1.2. JMS VS AMQP

### 1.2.1. JMS 简介

JMS(JAVA Message Service, java 消息服务),JMS 的客户端之间可以通过 JMS 进行异步的
消息传输.

JMS 是一个消息服务的标准/规范,允许应用程序组件基于 JavaEE 平台创建,发送,接收和读
取消息.它使分布式通信耦合度更低,消息服务更加可靠以及异步性.

### 1.2.2. JMS 两种消息模型

#### 1.2.2.1. 点到点 (P2P) 模型

![picture 5](../.vuepress/public/assets/images/1640739519156.png)

使用队列 (Queue) 作为消息通信载体; 满足生产者与消费者模式,一条消息只能被一个消费
者使用,未被消费的消息在队列中保留直到被消费或超时.

> 比如:生产者发送 100 条消息的话,两个消费者来消费一般情况下两个消费者会按照消息
> 发送的顺序各自消费一半

#### 1.2.2.2. 发布/订阅 (Pub/Sub) 模型

![picture 6](../.vuepress/public/assets/images/1640739602283.png)

发布订阅模型 (Pub/Sub) 使用主题 (Topic) 作为消息通信载体,类似于广播模式; 发布者
发布一条消息,该消息通过主题传递给所有的订阅者,在一条消息广播之后才订阅的用户则是
收不到该条消息的.

### 1.2.3. JMS 五种不同的消息正文格式

JMS 定义了五种不同的消息正文格式,以及调用的消息类型,允许发送并接收以一些不同形式
的数据,简单文本 (TextMessage), 可序列化的对象 (ObjectMessage), 键值对
(MapMessage), 字节流 (BytesMessage), 原始值流 (StreamMessage)

### 1.2.4. AMQP

AMQP (Advanced Message Queuing Protocol, 高级消息队列协议), 一个提供统一消息服务
的应用层标准高级消息队列协议,是应用层协议的一个开放标准,为面向消息的中间件设计,
兼容 JMS. 基于此协议的客户端与消息中间件可传递消息,并不受客户端/中间件同产品,不
同的开发语言等条件的限制.

生产者将消息发送给交换器,交换器和队列绑定,RabbitMQ 就是基于 AMQP 协议实现的.

### 1.2.5. AMQP 模型的几大组件?

1. 交换器 (Exchange): 消息代理服务器中用于把消息路由到队列的组件.
1. 队列 (Queue): 用来存储消息的数据结构,位于硬盘或内存中.
1. 绑定 (Binding): 一套规则,告知交换器消息应该将消息投递给哪个队列.

### 1.2.6. JMS vs AMQP

| 对比方向     | JMS                                     | AMQP                                                                                                                                                                                          |
| :----------- | :-------------------------------------- | :-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| 定义         | Java API                                | 协议                                                                                                                                                                                          |
| 跨语言       | 否                                      | 是                                                                                                                                                                                            |
| 跨平台       | 否                                      | 是                                                                                                                                                                                            |
| 支持消息类型 | 提供两种消息模型:1. 点对点 2. 发布/订阅 | 提供了五种消息模型:①direct exchange; ②fanout exchange; ③topic change; ④headers exchange; ⑤system exchange.本质来讲,后四种和 JMS 的 pub/sub 模型没有太大差别,仅是在路由机制上做了更详细的划分; |
| 支持消息类型 | 支持多种消息类型                        | byte[](二进制)                                                                                                                                                                                |

总结:

- AMQP 为消息定义了线路层 (wire-level protocol) 的协议,而 JMS 所定义的是 API 规
  范.在 Java 体系中,多个 client 均可以通过 JMS 进行交互,不需要应用修改代码,但是
  其对跨平台的支持较差.而 AMQP 天然具有跨平台,跨语言特性.
- JMS 支持 TextMessage, MapMessage 等复杂的消息类型; 而 AMQP 仅支持 byte[] 消息
  类型 (复杂的类型可序列化后发送).
- 由于 Exchange 提供的路由算法,AMQP 可以提供多样化的路由方式来传递消息到消息队列
  ,而 JMS 仅支持 队列 和 主题/订阅 方式两种.

## 1.3. 常见的消息队列对比

| 对比方向 | 概要                                                                                                                                                                     |
| -------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
| 吞吐量   | 万级的 ActiveMQ 和 RabbitMQ 的吞吐量 (ActiveMQ 的性能最差) 要比十万级甚至是百万级的 RocketMQ 和 Kafka 低一个数量级.                                                      |
| 可用性   | 都可以实现高可用.ActiveMQ 和 RabbitMQ 都是基于主从架构实现高可用性.RocketMQ 基于分布式架构. kafka 也是分布式的,一个数据多个副本,少数机器宕机,不会丢失数据,不会导致不可用 |
| 时效性   | RabbitMQ 基于 erlang 开发,所以并发能力很强,性能极其好,延时很低,达到微秒级.其他三个都是 ms 级.                                                                            |
| 功能支持 | 除了 Kafka,其他三个功能都较为完备. Kafka 功能较为简单,主要支持简单的 MQ 功能,在大数据领域的实时计算以及日志采集被大规模使用,是事实上的标准                               |
| 消息丢失 | ActiveMQ 和 RabbitMQ 丢失的可能性非常低,RocketMQ 和 Kafka 理论上不会丢失.                                                                                                |

## 1.4. MQ如何保证分布式事务的最终一致性

![picture 2](../.vuepress/public/assets/images/1644540373312.png)  

分布式事务: 业务相关的多个操作,保证他们同时成功或者同时失败

最终一致性: 对于已改变数据的读取,最终都能获取已更新的数据,但不保证能立即获取已更新的数据

### 1.4.1. MQ中要保证事务的最终一致性,需要做到

1. 生产者要保证100%的消息投递.事务消息机制
1. 消费者这一端需要保证幂等消费.唯一ID+业务自己实现的幂等

## 1.5. 设计一个高并发的消息中间件

### 1.5.1. 生产者消费者模型

消息中间件能够使其他应用来生产消息，也能够使其他应用来消费相应的消息。如果生产者生产了消息，消息中间件存储相应的数据在内存和磁盘中

### 1.5.2. 数据的高可用

通过本地内存，分布式缓存，和一份数据在不同的服务器上都搞一个副本来实现的。此时，任何一个存储节点宕机，都不会影响整体的高可用。

### 1.5.3. 消息数据不丢失

一种 ACK 对应的是生产端。如果一直没有接收到 ACK 消息，则需要通过生产者来重新发送一条消息来保证生产消息成功。

另一种 ACK 对应的是消费端。一旦一条消息消费并处理成功，必须返回一个 ack 给消息中间件，然后消息中间件才能删除这条消息。否则一旦消费者宕机，就必须重发这条消息给其他的消费者实例，保证消息一定会被处理成功。
